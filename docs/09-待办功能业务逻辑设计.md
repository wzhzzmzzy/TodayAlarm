# 定时提醒小助手 - 待办功能业务逻辑设计

## 1. 概述

本文档详细描述待办功能的业务逻辑设计，包括用例(UseCase)设计、ViewModel架构、状态管理、数据流处理以及业务规则定义。

## 2. 用例(UseCase)设计

### 2.1 核心用例架构

```kotlin
// domain/usecase/todo/TodoUseCases.kt
data class TodoUseCases(
    val getTodoItems: GetTodoItemsUseCase,
    val getTodoItemById: GetTodoItemByIdUseCase,
    val createTodoItem: CreateTodoItemUseCase,
    val updateTodoItem: UpdateTodoItemUseCase,
    val deleteTodoItem: DeleteTodoItemUseCase,
    val completeTodoItem: CompleteTodoItemUseCase,
    val snoozeTodoItem: SnoozeTodoItemUseCase,
    val batchOperateTodoItems: BatchOperateTodoItemsUseCase,
    val getTodoStatistics: GetTodoStatisticsUseCase,
    val syncTodoWithPlan: SyncTodoWithPlanUseCase,
    val cleanupTodoItems: CleanupTodoItemsUseCase
)
```

### 2.2 获取待办用例

```kotlin
// domain/usecase/todo/GetTodoItemsUseCase.kt
class GetTodoItemsUseCase @Inject constructor(
    private val todoRepository: TodoItemRepository
) {

    data class Params(
        val filter: TodoFilter = TodoFilter.ALL,
        val sortBy: TodoSortBy = TodoSortBy.TIME_ASC,
        val timeRange: TodoTimeRange? = null,
        val category: TodoCategory? = null,
        val priority: TodoPriority? = null,
        val searchQuery: String? = null
    )

    operator fun invoke(params: Params): Flow<List<TodoItem>> {
        return when (params.filter) {
            TodoFilter.ALL -> todoRepository.getAllTodoItems()
            TodoFilter.PENDING -> todoRepository.getPendingTodoItems()
            TodoFilter.COMPLETED -> todoRepository.getCompletedTodoItems()
            TodoFilter.OVERDUE -> todoRepository.getOverdueTodoItems()
            TodoFilter.TODAY -> todoRepository.getTodayTodoItems()
            TodoFilter.THIS_WEEK -> todoRepository.getThisWeekTodoItems()
            TodoFilter.SNOOZED -> todoRepository.getSnoozedTodoItems()
            TodoFilter.BY_CATEGORY -> params.category?.let {
                todoRepository.getTodoItemsByCategory(it)
            } ?: todoRepository.getAllTodoItems()
            TodoFilter.BY_PRIORITY -> params.priority?.let {
                todoRepository.getTodoItemsByPriority(it)
            } ?: todoRepository.getAllTodoItems()
            TodoFilter.SEARCH -> params.searchQuery?.let {
                todoRepository.searchTodoItems(it)
            } ?: todoRepository.getAllTodoItems()
            TodoFilter.TIME_RANGE -> params.timeRange?.let {
                todoRepository.getTodoItemsInTimeRange(it.startTime, it.endTime)
            } ?: todoRepository.getAllTodoItems()
        }.map { todoItems ->
            // 应用排序
            when (params.sortBy) {
                TodoSortBy.TIME_ASC -> todoItems.sortedBy { it.triggerTime }
                TodoSortBy.TIME_DESC -> todoItems.sortedByDescending { it.triggerTime }
                TodoSortBy.PRIORITY_DESC -> todoItems.sortedWith(
                    compareByDescending<TodoItem> { it.getPriorityEnum().ordinal }
                        .thenBy { it.triggerTime }
                )
                TodoSortBy.STATUS -> todoItems.sortedWith(
                    compareBy<TodoItem> { it.isCompleted() }
                        .thenBy { it.triggerTime }
                )
                TodoSortBy.CREATED_DESC -> todoItems.sortedByDescending { it.createdAt }
                TodoSortBy.UPDATED_DESC -> todoItems.sortedByDescending { it.updatedAt }
            }
        }
    }
}

enum class TodoFilter {
    ALL, PENDING, COMPLETED, OVERDUE, TODAY, THIS_WEEK, SNOOZED,
    BY_CATEGORY, BY_PRIORITY, SEARCH, TIME_RANGE
}

enum class TodoSortBy {
    TIME_ASC, TIME_DESC, PRIORITY_DESC, STATUS, CREATED_DESC, UPDATED_DESC
}
```

### 2.3 创建待办用例

```kotlin
// domain/usecase/todo/CreateTodoItemUseCase.kt
class CreateTodoItemUseCase @Inject constructor(
    private val todoRepository: TodoItemRepository,
    private val planRepository: PlanRepository,
    private val notificationManager: TodoNotificationManager
) {

    data class Params(
        val title: String,
        val content: String,
        val triggerTime: Long,
        val planId: String? = null,
        val priority: TodoPriority = TodoPriority.NORMAL,
        val category: TodoCategory = TodoCategory.GENERAL,
        val tags: List<TodoTag> = emptyList(),
        val reminderEnabled: Boolean = true,
        val metadata: TodoMetadata = TodoMetadata()
    )

    suspend operator fun invoke(params: Params): Result<TodoItem> {
        return try {
            // 验证输入参数
            validateParams(params)

            // 创建待办事项
            val todoItem = TodoItem(
                planId = params.planId ?: "",
                title = params.title.trim(),
                content = params.content.trim(),
                triggerTime = params.triggerTime,
                priority = params.priority.name,
                category = params.category.name,
                tags = Json.encodeToString(params.tags),
                reminderEnabled = params.reminderEnabled,
                reminderTime = if (params.reminderEnabled) params.triggerTime else null,
                metadata = Json.encodeToString(params.metadata)
            )

            // 保存到数据库
            todoRepository.insertTodoItem(todoItem)

            // 如果启用提醒，设置通知
            if (params.reminderEnabled && params.triggerTime > System.currentTimeMillis()) {
                notificationManager.scheduleNotification(todoItem)
            }

            Result.success(todoItem)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    private fun validateParams(params: Params) {
        require(params.title.isNotBlank()) { "标题不能为空" }
        require(params.triggerTime > 0) { "触发时间无效" }
        require(params.content.length <= 500) { "内容长度不能超过500字符" }
    }
}
```

### 2.4 完成待办用例

```kotlin
// domain/usecase/todo/CompleteTodoItemUseCase.kt
class CompleteTodoItemUseCase @Inject constructor(
    private val todoRepository: TodoItemRepository,
    private val notificationManager: TodoNotificationManager,
    private val analyticsManager: TodoAnalyticsManager
) {

    data class Params(
        val todoId: String,
        val completedAt: Long = System.currentTimeMillis(),
        val notes: String? = null
    )

    suspend operator fun invoke(params: Params): Result<Unit> {
        return try {
            // 获取待办事项
            val todoItem = todoRepository.getTodoItemById(params.todoId)
                ?: throw IllegalArgumentException("待办事项不存在")

            // 检查是否已完成
            if (todoItem.isCompleted()) {
                throw IllegalStateException("待办事项已完成")
            }

            // 更新完成状态
            todoRepository.completeTodoItem(params.todoId)

            // 取消相关通知
            notificationManager.cancelNotification(todoItem)

            // 记录完成分析数据
            analyticsManager.recordCompletion(todoItem, params.completedAt)

            // 如果有备注，更新元数据
            params.notes?.let { notes ->
                val updatedTodo = todoItem.copy(
                    metadata = Json.encodeToString(
                        todoItem.getMetadataObject().copy(notes = notes)
                    ),
                    updatedAt = System.currentTimeMillis()
                )
                todoRepository.updateTodoItem(updatedTodo)
            }

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### 2.5 推迟待办用例

```kotlin
// domain/usecase/todo/SnoozeTodoItemUseCase.kt
class SnoozeTodoItemUseCase @Inject constructor(
    private val todoRepository: TodoItemRepository,
    private val notificationManager: TodoNotificationManager
) {

    data class Params(
        val todoId: String,
        val snoozeMinutes: Int,
        val maxSnoozeCount: Int = 3
    )

    suspend operator fun invoke(params: Params): Result<Unit> {
        return try {
            // 获取待办事项
            val todoItem = todoRepository.getTodoItemById(params.todoId)
                ?: throw IllegalArgumentException("待办事项不存在")

            // 检查是否可以推迟
            if (!todoItem.canSnooze()) {
                throw IllegalStateException("已达到最大推迟次数")
            }

            if (todoItem.isCompleted()) {
                throw IllegalStateException("已完成的待办不能推迟")
            }

            // 计算新的提醒时间
            val newReminderTime = System.currentTimeMillis() + (params.snoozeMinutes * 60 * 1000)

            // 更新推迟状态
            todoRepository.snoozeTodoItem(params.todoId, params.snoozeMinutes)

            // 重新安排通知
            val updatedTodo = todoItem.copy(
                status = TodoStatus.SNOOZED.name,
                reminderTime = newReminderTime,
                snoozeCount = todoItem.snoozeCount + 1
            )
            notificationManager.rescheduleNotification(updatedTodo)

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### 2.6 批量操作用例

```kotlin
// domain/usecase/todo/BatchOperateTodoItemsUseCase.kt
class BatchOperateTodoItemsUseCase @Inject constructor(
    private val todoRepository: TodoItemRepository,
    private val notificationManager: TodoNotificationManager
) {

    data class Params(
        val todoIds: List<String>,
        val operation: BatchOperation
    )

    sealed class BatchOperation {
        object Complete : BatchOperation()
        object Delete : BatchOperation()
        object Archive : BatchOperation()
        data class UpdatePriority(val priority: TodoPriority) : BatchOperation()
        data class UpdateCategory(val category: TodoCategory) : BatchOperation()
    }

    suspend operator fun invoke(params: Params): Result<Int> {
        return try {
            if (params.todoIds.isEmpty()) {
                return Result.success(0)
            }

            val affectedCount = when (params.operation) {
                is BatchOperation.Complete -> {
                    todoRepository.batchCompleteTodoItems(params.todoIds)
                    // 取消相关通知
                    params.todoIds.forEach { id ->
                        todoRepository.getTodoItemById(id)?.let { todo ->
                            notificationManager.cancelNotification(todo)
                        }
                    }
                    params.todoIds.size
                }

                is BatchOperation.Delete -> {
                    // 先取消通知
                    params.todoIds.forEach { id ->
                        todoRepository.getTodoItemById(id)?.let { todo ->
                            notificationManager.cancelNotification(todo)
                        }
                    }
                    todoRepository.batchDeleteTodoItems(params.todoIds)
                    params.todoIds.size
                }

                is BatchOperation.Archive -> {
                    todoRepository.batchArchiveTodoItems(params.todoIds)
                    params.todoIds.size
                }

                is BatchOperation.UpdatePriority -> {
                    var count = 0
                    params.todoIds.forEach { id ->
                        try {
                            todoRepository.updateTodoItemPriority(id, params.operation.priority)
                            count++
                        } catch (e: Exception) {
                            // 记录错误但继续处理其他项目
                        }
                    }
                    count
                }

                is BatchOperation.UpdateCategory -> {
                    var count = 0
                    params.todoIds.forEach { id ->
                        try {
                            todoRepository.updateTodoItemCategory(id, params.operation.category)
                            count++
                        } catch (e: Exception) {
                            // 记录错误但继续处理其他项目
                        }
                    }
                    count
                }
            }

            Result.success(affectedCount)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### 2.7 统计分析用例

```kotlin
// domain/usecase/todo/GetTodoStatisticsUseCase.kt
class GetTodoStatisticsUseCase @Inject constructor(
    private val todoRepository: TodoItemRepository
) {

    data class Params(
        val timeRange: TodoTimeRange? = null,
        val includeArchived: Boolean = false
    )

    suspend operator fun invoke(params: Params): Result<TodoStatistics> {
        return try {
            val statistics = if (params.timeRange != null) {
                todoRepository.getTodoStatisticsInTimeRange(
                    params.timeRange.startTime,
                    params.timeRange.endTime
                )
            } else {
                todoRepository.getTodoStatistics()
            }

            // 计算额外的统计信息
            val enhancedStatistics = statistics.copy(
                completionRate = if (statistics.totalCount > 0) {
                    statistics.completedCount.toFloat() / statistics.totalCount
                } else 0f
            )

            Result.success(enhancedStatistics)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### 2.8 同步计划和待办用例

```kotlin
// domain/usecase/todo/SyncTodoWithPlanUseCase.kt
class SyncTodoWithPlanUseCase @Inject constructor(
    private val todoRepository: TodoItemRepository,
    private val planRepository: PlanRepository,
    private val notificationManager: TodoNotificationManager
) {

    data class Params(
        val planId: String,
        val triggerTime: Long
    )

    suspend operator fun invoke(params: Params): Result<TodoItem> {
        return try {
            // 获取计划信息
            val plan = planRepository.getPlanById(params.planId)
                ?: throw IllegalArgumentException("计划不存在")

            // 检查是否已存在相同触发时间的待办
            val existingTodos = todoRepository.getTodoItemsByPlanId(params.planId).first()
            val existingTodo = existingTodos.find { it.triggerTime == params.triggerTime }

            if (existingTodo != null) {
                return Result.success(existingTodo)
            }

            // 创建新的待办事项
            val todoItem = TodoItemFactory.createFromPlan(plan, params.triggerTime)
            todoRepository.insertTodoItem(todoItem)

            // 设置通知
            if (todoItem.reminderEnabled && params.triggerTime > System.currentTimeMillis()) {
                notificationManager.scheduleNotification(todoItem)
            }

            Result.success(todoItem)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

## 3. ViewModel 架构设计

### 3.1 TodoListViewModel

```kotlin
// ui/viewmodel/TodoListViewModel.kt
@HiltViewModel
class TodoListViewModel @Inject constructor(
    private val todoUseCases: TodoUseCases,
    private val userPreferencesDataStore: UserPreferencesDataStore
) : ViewModel() {

    private val _uiState = MutableStateFlow(TodoListUiState())
    val uiState: StateFlow<TodoListUiState> = _uiState.asStateFlow()

    private val _uiEvent = Channel<TodoListUiEvent>()
    val uiEvent = _uiEvent.receiveAsFlow()

    init {
        loadTodoItems()
        observeUserPreferences()
    }

    fun onAction(action: TodoListAction) {
        when (action) {
            is TodoListAction.LoadTodoItems -> loadTodoItems(action.filter, action.sortBy)
            is TodoListAction.RefreshTodoItems -> refreshTodoItems()
            is TodoListAction.SearchTodoItems -> searchTodoItems(action.query)
            is TodoListAction.FilterByCategory -> filterByCategory(action.category)
            is TodoListAction.FilterByPriority -> filterByPriority(action.priority)
            is TodoListAction.CompleteTodoItem -> completeTodoItem(action.todoId)
            is TodoListAction.SnoozeTodoItem -> snoozeTodoItem(action.todoId, action.minutes)
            is TodoListAction.DeleteTodoItem -> deleteTodoItem(action.todoId)
            is TodoListAction.SelectTodoItem -> selectTodoItem(action.todoId)
            is TodoListAction.DeselectTodoItem -> deselectTodoItem(action.todoId)
            is TodoListAction.SelectAllTodoItems -> selectAllTodoItems()
            is TodoListAction.DeselectAllTodoItems -> deselectAllTodoItems()
            is TodoListAction.BatchComplete -> batchCompleteTodoItems()
            is TodoListAction.BatchDelete -> batchDeleteTodoItems()
            is TodoListAction.BatchArchive -> batchArchiveTodoItems()
            is TodoListAction.UpdateFilter -> updateFilter(action.filter)
            is TodoListAction.UpdateSortBy -> updateSortBy(action.sortBy)
        }
    }

    private fun loadTodoItems(
        filter: TodoFilter = _uiState.value.currentFilter,
        sortBy: TodoSortBy = _uiState.value.currentSortBy
    ) {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, error = null) }

            try {
                val params = GetTodoItemsUseCase.Params(
                    filter = filter,
                    sortBy = sortBy,
                    timeRange = _uiState.value.timeRange,
                    category = _uiState.value.selectedCategory,
                    priority = _uiState.value.selectedPriority,
                    searchQuery = _uiState.value.searchQuery
                )

                todoUseCases.getTodoItems(params).collect { todoItems ->
                    _uiState.update { currentState ->
                        currentState.copy(
                            todoItems = todoItems,
                            isLoading = false,
                            error = null,
                            currentFilter = filter,
                            currentSortBy = sortBy
                        )
                    }
                }
            } catch (e: Exception) {
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        error = e.message ?: "加载待办事项失败"
                    )
                }
            }
        }
    }

    private fun completeTodoItem(todoId: String) {
        viewModelScope.launch {
            val result = todoUseCases.completeTodoItem(
                CompleteTodoItemUseCase.Params(todoId = todoId)
            )

            result.fold(
                onSuccess = {
                    _uiEvent.send(TodoListUiEvent.ShowMessage("待办已完成"))
                },
                onFailure = { error ->
                    _uiEvent.send(TodoListUiEvent.ShowError(error.message ?: "完成失败"))
                }
            )
        }
    }

    private fun snoozeTodoItem(todoId: String, minutes: Int) {
        viewModelScope.launch {
            val result = todoUseCases.snoozeTodoItem(
                SnoozeTodoItemUseCase.Params(
                    todoId = todoId,
                    snoozeMinutes = minutes
                )
            )

            result.fold(
                onSuccess = {
                    _uiEvent.send(TodoListUiEvent.ShowMessage("已推迟 $minutes 分钟"))
                },
                onFailure = { error ->
                    _uiEvent.send(TodoListUiEvent.ShowError(error.message ?: "推迟失败"))
                }
            )
        }
    }

    private fun batchCompleteTodoItems() {
        viewModelScope.launch {
            val selectedIds = _uiState.value.selectedTodoIds
            if (selectedIds.isEmpty()) return@launch

            val result = todoUseCases.batchOperateTodoItems(
                BatchOperateTodoItemsUseCase.Params(
                    todoIds = selectedIds,
                    operation = BatchOperateTodoItemsUseCase.BatchOperation.Complete
                )
            )

            result.fold(
                onSuccess = { count ->
                    _uiState.update { it.copy(selectedTodoIds = emptySet()) }
                    _uiEvent.send(TodoListUiEvent.ShowMessage("已完成 $count 个待办"))
                },
                onFailure = { error ->
                    _uiEvent.send(TodoListUiEvent.ShowError(error.message ?: "批量操作失败"))
                }
            )
        }
    }

    private fun searchTodoItems(query: String) {
        _uiState.update { it.copy(searchQuery = query) }
        loadTodoItems(TodoFilter.SEARCH)
    }

    private fun selectTodoItem(todoId: String) {
        _uiState.update { currentState ->
            currentState.copy(
                selectedTodoIds = currentState.selectedTodoIds + todoId
            )
        }
    }

    private fun observeUserPreferences() {
        viewModelScope.launch {
            userPreferencesDataStore.userPreferences.collect { preferences ->
                _uiState.update { currentState ->
                    currentState.copy(
                        timeFormat24Hour = preferences.timeFormat24Hour,
                        weekStartDay = preferences.weekStartDay
                    )
                }
            }
        }
    }
}

// UI状态
data class TodoListUiState(
    val todoItems: List<TodoItem> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null,
    val currentFilter: TodoFilter = TodoFilter.ALL,
    val currentSortBy: TodoSortBy = TodoSortBy.TIME_ASC,
    val searchQuery: String? = null,
    val selectedCategory: TodoCategory? = null,
    val selectedPriority: TodoPriority? = null,
    val timeRange: TodoTimeRange? = null,
    val selectedTodoIds: Set<String> = emptySet(),
    val isSelectionMode: Boolean = false,
    val timeFormat24Hour: Boolean = true,
    val weekStartDay: Int = 1
) {
    val hasSelectedItems: Boolean = selectedTodoIds.isNotEmpty()
    val selectedCount: Int = selectedTodoIds.size
}

// UI动作
sealed class TodoListAction {
    data class LoadTodoItems(
        val filter: TodoFilter = TodoFilter.ALL,
        val sortBy: TodoSortBy = TodoSortBy.TIME_ASC
    ) : TodoListAction()

    object RefreshTodoItems : TodoListAction()
    data class SearchTodoItems(val query: String) : TodoListAction()
    data class FilterByCategory(val category: TodoCategory?) : TodoListAction()
    data class FilterByPriority(val priority: TodoPriority?) : TodoListAction()
    data class CompleteTodoItem(val todoId: String) : TodoListAction()
    data class SnoozeTodoItem(val todoId: String, val minutes: Int) : TodoListAction()
    data class DeleteTodoItem(val todoId: String) : TodoListAction()
    data class SelectTodoItem(val todoId: String) : TodoListAction()
    data class DeselectTodoItem(val todoId: String) : TodoListAction()
    object SelectAllTodoItems : TodoListAction()
    object DeselectAllTodoItems : TodoListAction()
    object BatchComplete : TodoListAction()
    object BatchDelete : TodoListAction()
    object BatchArchive : TodoListAction()
    data class UpdateFilter(val filter: TodoFilter) : TodoListAction()
    data class UpdateSortBy(val sortBy: TodoSortBy) : TodoListAction()
}

// UI事件
sealed class TodoListUiEvent {
    data class ShowMessage(val message: String) : TodoListUiEvent()
    data class ShowError(val error: String) : TodoListUiEvent()
    data class NavigateToDetail(val todoId: String) : TodoListUiEvent()
    object NavigateToCreate : TodoListUiEvent()
}
```

### 3.2 TodoDetailViewModel

```kotlin
// ui/viewmodel/TodoDetailViewModel.kt
@HiltViewModel
class TodoDetailViewModel @Inject constructor(
    private val todoUseCases: TodoUseCases,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val todoId: String = savedStateHandle.get<String>("todoId") ?: ""

    private val _uiState = MutableStateFlow(TodoDetailUiState())
    val uiState: StateFlow<TodoDetailUiState> = _uiState.asStateFlow()

    private val _uiEvent = Channel<TodoDetailUiEvent>()
    val uiEvent = _uiEvent.receiveAsFlow()

    init {
        if (todoId.isNotEmpty()) {
            loadTodoItem()
        }
    }

    fun onAction(action: TodoDetailAction) {
        when (action) {
            is TodoDetailAction.LoadTodoItem -> loadTodoItem()
            is TodoDetailAction.UpdateTitle -> updateTitle(action.title)
            is TodoDetailAction.UpdateContent -> updateContent(action.content)
            is TodoDetailAction.UpdatePriority -> updatePriority(action.priority)
            is TodoDetailAction.UpdateCategory -> updateCategory(action.category)
            is TodoDetailAction.UpdateTriggerTime -> updateTriggerTime(action.time)
            is TodoDetailAction.AddTag -> addTag(action.tag)
            is TodoDetailAction.RemoveTag -> removeTag(action.tag)
            is TodoDetailAction.SaveTodoItem -> saveTodoItem()
            is TodoDetailAction.CompleteTodoItem -> completeTodoItem()
            is TodoDetailAction.SnoozeTodoItem -> snoozeTodoItem(action.minutes)
            is TodoDetailAction.DeleteTodoItem -> deleteTodoItem()
        }
    }

    private fun loadTodoItem() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }

            try {
                val todoItem = todoUseCases.getTodoItemById(todoId)
                if (todoItem != null) {
                    _uiState.update { currentState ->
                        currentState.copy(
                            todoItem = todoItem,
                            title = todoItem.title,
                            content = todoItem.content,
                            priority = todoItem.getPriorityEnum(),
                            category = todoItem.getCategoryEnum(),
                            triggerTime = todoItem.triggerTime,
                            tags = todoItem.getTagList(),
                            isLoading = false,
                            error = null
                        )
                    }
                } else {
                    _uiState.update {
                        it.copy(
                            isLoading = false,
                            error = "待办事项不存在"
                        )
                    }
                }
            } catch (e: Exception) {
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        error = e.message ?: "加载失败"
                    )
                }
            }
        }
    }

    private fun saveTodoItem() {
        viewModelScope.launch {
            val currentState = _uiState.value
            val todoItem = currentState.todoItem ?: return@launch

            if (!validateInput(currentState)) {
                return@launch
            }

            _uiState.update { it.copy(isSaving = true) }

            try {
                val updatedTodo = todoItem.copy(
                    title = currentState.title,
                    content = currentState.content,
                    priority = currentState.priority.name,
                    category = currentState.category.name,
                    triggerTime = currentState.triggerTime,
                    tags = Json.encodeToString(currentState.tags),
                    updatedAt = System.currentTimeMillis()
                )

                val result = todoUseCases.updateTodoItem(
                    UpdateTodoItemUseCase.Params(updatedTodo)
                )

                result.fold(
                    onSuccess = {
                        _uiState.update { it.copy(isSaving = false, hasUnsavedChanges = false) }
                        _uiEvent.send(TodoDetailUiEvent.ShowMessage("保存成功"))
                        _uiEvent.send(TodoDetailUiEvent.NavigateBack)
                    },
                    onFailure = { error ->
                        _uiState.update { it.copy(isSaving = false) }
                        _uiEvent.send(TodoDetailUiEvent.ShowError(error.message ?: "保存失败"))
                    }
                )
            } catch (e: Exception) {
                _uiState.update { it.copy(isSaving = false) }
                _uiEvent.send(TodoDetailUiEvent.ShowError(e.message ?: "保存失败"))
            }
        }
    }

    private fun validateInput(state: TodoDetailUiState): Boolean {
        return when {
            state.title.isBlank() -> {
                viewModelScope.launch {
                    _uiEvent.send(TodoDetailUiEvent.ShowError("标题不能为空"))
                }
                false
            }
            state.triggerTime <= 0 -> {
                viewModelScope.launch {
                    _uiEvent.send(TodoDetailUiEvent.ShowError("请设置有效的触发时间"))
                }
                false
            }
            else -> true
        }
    }

    private fun updateTitle(title: String) {
        _uiState.update {
            it.copy(
                title = title,
                hasUnsavedChanges = true
            )
        }
    }

    private fun completeTodoItem() {
        viewModelScope.launch {
            val result = todoUseCases.completeTodoItem(
                CompleteTodoItemUseCase.Params(todoId = todoId)
            )

            result.fold(
                onSuccess = {
                    _uiEvent.send(TodoDetailUiEvent.ShowMessage("待办已完成"))
                    _uiEvent.send(TodoDetailUiEvent.NavigateBack)
                },
                onFailure = { error ->
                    _uiEvent.send(TodoDetailUiEvent.ShowError(error.message ?: "完成失败"))
                }
            )
        }
    }
}

// UI状态
data class TodoDetailUiState(
    val todoItem: TodoItem? = null,
    val title: String = "",
    val content: String = "",
    val priority: TodoPriority = TodoPriority.NORMAL,
    val category: TodoCategory = TodoCategory.GENERAL,
    val triggerTime: Long = System.currentTimeMillis(),
    val tags: List<TodoTag> = emptyList(),
    val isLoading: Boolean = false,
    val isSaving: Boolean = false,
    val error: String? = null,
    val hasUnsavedChanges: Boolean = false
)

// UI动作
sealed class TodoDetailAction {
    object LoadTodoItem : TodoDetailAction()
    data class UpdateTitle(val title: String) : TodoDetailAction()
    data class UpdateContent(val content: String) : TodoDetailAction()
    data class UpdatePriority(val priority: TodoPriority) : TodoDetailAction()
    data class UpdateCategory(val category: TodoCategory) : TodoDetailAction()
    data class UpdateTriggerTime(val time: Long) : TodoDetailAction()
    data class AddTag(val tag: TodoTag) : TodoDetailAction()
    data class RemoveTag(val tag: TodoTag) : TodoDetailAction()
    object SaveTodoItem : TodoDetailAction()
    object CompleteTodoItem : TodoDetailAction()
    data class SnoozeTodoItem(val minutes: Int) : TodoDetailAction()
    object DeleteTodoItem : TodoDetailAction()
}

// UI事件
sealed class TodoDetailUiEvent {
    data class ShowMessage(val message: String) : TodoDetailUiEvent()
    data class ShowError(val error: String) : TodoDetailUiEvent()
    object NavigateBack : TodoDetailUiEvent()
    data class NavigateToEdit(val todoId: String) : TodoDetailUiEvent()
}
```

## 4. 业务规则和验证

### 4.1 业务规则管理器

```kotlin
// domain/rules/TodoBusinessRules.kt
class TodoBusinessRules {

    companion object {
        const val MAX_TITLE_LENGTH = 100
        const val MAX_CONTENT_LENGTH = 500
        const val MAX_SNOOZE_COUNT = 3
        const val MAX_TAGS_COUNT = 10
        const val MIN_TRIGGER_TIME_OFFSET = 60_000L // 1分钟
    }

    fun validateTodoCreation(params: CreateTodoItemUseCase.Params): ValidationResult {
        val errors = mutableListOf<String>()

        // 标题验证
        if (params.title.isBlank()) {
            errors.add("标题不能为空")
        } else if (params.title.length > MAX_TITLE_LENGTH) {
            errors.add("标题长度不能超过 $MAX_TITLE_LENGTH 字符")
        }

        // 内容验证
        if (params.content.length > MAX_CONTENT_LENGTH) {
            errors.add("内容长度不能超过 $MAX_CONTENT_LENGTH 字符")
        }

        // 时间验证
        val now = System.currentTimeMillis()
        if (params.triggerTime <= now + MIN_TRIGGER_TIME_OFFSET) {
            errors.add("触发时间必须至少在1分钟后")
        }

        // 标签验证
        if (params.tags.size > MAX_TAGS_COUNT) {
            errors.add("标签数量不能超过 $MAX_TAGS_COUNT 个")
        }

        return if (errors.isEmpty()) {
            ValidationResult.Success
        } else {
            ValidationResult.Error(errors)
        }
    }

    fun validateTodoCompletion(todoItem: TodoItem): ValidationResult {
        val errors = mutableListOf<String>()

        if (todoItem.isCompleted()) {
            errors.add("待办事项已完成")
        }

        if (todoItem.isCancelled()) {
            errors.add("已取消的待办事项不能完成")
        }

        return if (errors.isEmpty()) {
            ValidationResult.Success
        } else {
            ValidationResult.Error(errors)
        }
    }

    fun validateTodoSnooze(todoItem: TodoItem, snoozeMinutes: Int): ValidationResult {
        val errors = mutableListOf<String>()

        if (todoItem.isCompleted()) {
            errors.add("已完成的待办不能推迟")
        }

        if (todoItem.snoozeCount >= MAX_SNOOZE_COUNT) {
            errors.add("已达到最大推迟次数")
        }

        if (snoozeMinutes <= 0) {
            errors.add("推迟时间必须大于0")
        }

        if (snoozeMinutes > 24 * 60) { // 24小时
            errors.add("推迟时间不能超过24小时")
        }

        return if (errors.isEmpty()) {
            ValidationResult.Success
        } else {
            ValidationResult.Error(errors)
        }
    }
}

sealed class ValidationResult {
    object Success : ValidationResult()
    data class Error(val errors: List<String>) : ValidationResult()
}
```

## 5. 数据流管理

### 5.1 TodoDataFlow

```kotlin
// domain/dataflow/TodoDataFlow.kt
@Singleton
class TodoDataFlow @Inject constructor(
    private val todoRepository: TodoItemRepository,
    private val scope: CoroutineScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
) {

    private val _todoUpdates = MutableSharedFlow<TodoUpdate>()
    val todoUpdates: SharedFlow<TodoUpdate> = _todoUpdates.asSharedFlow()

    init {
        observeTodoChanges()
    }

    private fun observeTodoChanges() {
        scope.launch {
            todoRepository.getAllTodoItems().collect { todoItems ->
                _todoUpdates.emit(TodoUpdate.ListChanged(todoItems))
            }
        }
    }

    suspend fun emitTodoCreated(todoItem: TodoItem) {
        _todoUpdates.emit(TodoUpdate.Created(todoItem))
    }

    suspend fun emitTodoUpdated(todoItem: TodoItem) {
        _todoUpdates.emit(TodoUpdate.Updated(todoItem))
    }

    suspend fun emitTodoCompleted(todoId: String) {
        _todoUpdates.emit(TodoUpdate.Completed(todoId))
    }

    suspend fun emitTodoDeleted(todoId: String) {
        _todoUpdates.emit(TodoUpdate.Deleted(todoId))
    }
}

sealed class TodoUpdate {
    data class ListChanged(val todoItems: List<TodoItem>) : TodoUpdate()
    data class Created(val todoItem: TodoItem) : TodoUpdate()
    data class Updated(val todoItem: TodoItem) : TodoUpdate()
    data class Completed(val todoId: String) : TodoUpdate()
    data class Deleted(val todoId: String) : TodoUpdate()
}
```

## 6. 错误处理和重试机制

### 6.1 TodoErrorHandler

```kotlin
// domain/error/TodoErrorHandler.kt
class TodoErrorHandler {

    fun handleError(error: Throwable): TodoError {
        return when (error) {
            is IllegalArgumentException -> TodoError.InvalidInput(error.message ?: "输入无效")
            is IllegalStateException -> TodoError.InvalidState(error.message ?: "状态无效")
            is SQLiteException -> TodoError.DatabaseError("数据库操作失败")
            is IOException -> TodoError.NetworkError("网络连接失败")
            is CancellationException -> TodoError.OperationCancelled
            else -> TodoError.Unknown(error.message ?: "未知错误")
        }
    }

    fun getErrorMessage(error: TodoError): String {
        return when (error) {
            is TodoError.InvalidInput -> error.message
            is TodoError.InvalidState -> error.message
            is TodoError.DatabaseError -> "数据存储出现问题，请稍后重试"
            is TodoError.NetworkError -> "网络连接异常，请检查网络设置"
            is TodoError.OperationCancelled -> "操作已取消"
            is TodoError.Unknown -> "出现未知错误：${error.message}"
        }
    }
}

sealed class TodoError {
    data class InvalidInput(val message: String) : TodoError()
    data class InvalidState(val message: String) : TodoError()
    data class DatabaseError(val message: String) : TodoError()
    data class NetworkError(val message: String) : TodoError()
    object OperationCancelled : TodoError()
    data class Unknown(val message: String) : TodoError()
}
```

## 7. 性能优化策略

### 7.1 缓存管理

```kotlin
// domain/cache/TodoCacheManager.kt
@Singleton
class TodoCacheManager @Inject constructor() {

    private val todoCache = LruCache<String, TodoItem>(100)
    private val statisticsCache = LruCache<String, TodoStatistics>(10)
    private val cacheExpiration = 5 * 60 * 1000L // 5分钟

    fun getTodoItem(id: String): TodoItem? {
        return todoCache.get(id)
    }

    fun putTodoItem(todoItem: TodoItem) {
        todoCache.put(todoItem.id, todoItem)
    }

    fun removeTodoItem(id: String) {
        todoCache.remove(id)
    }

    fun getStatistics(key: String): TodoStatistics? {
        return statisticsCache.get(key)
    }

    fun putStatistics(key: String, statistics: TodoStatistics) {
        statisticsCache.put(key, statistics)
    }

    fun clearCache() {
        todoCache.evictAll()
        statisticsCache.evictAll()
    }
}
```

## 8. 下一步

业务逻辑设计完成后，接下来需要：

1. **UI设计实现** (10-待办功能UI设计实现.md)
   - Compose UI 组件设计
   - 页面布局和交互
   - 主题和样式定义

2. **系统集成** (11-待办功能系统集成.md)
   - 通知系统集成
   - 闹钟触发处理
   - 后台任务管理

这个业务逻辑设计为待办功能提供了完整的业务处理能力，包括数据操作、状态管理、错误处理和性能优化。