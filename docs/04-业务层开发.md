# 定时提醒小助手 - 业务层开发指南

## 1. 开发概述

业务层负责封装应用的核心业务逻辑，包括：
- 业务模型定义
- 用例 (UseCase) 实现
- 业务规则和验证
- 数据转换和处理

## 2. 步骤一：创建业务模型

### 2.1 创建 UI 模型
```kotlin
// domain/model/PlanUiModel.kt
data class PlanUiModel(
    val id: String,
    val title: String,
    val content: String,
    val triggerTime: LocalDateTime,
    val isRepeating: Boolean,
    val repeatType: RepeatType,
    val repeatInterval: Int,
    val isActive: Boolean,
    val createdAt: LocalDateTime,
    val updatedAt: LocalDateTime,
    val nextTriggerTime: LocalDateTime? = null, // 下次触发时间
    val formattedTime: String = "", // 格式化的时间显示
    val formattedDate: String = "", // 格式化的日期显示
    val isOverdue: Boolean = false // 是否已过期
)
```

### 2.2 创建 TodoItem UI 模型
```kotlin
// domain/model/TodoItemUiModel.kt
data class TodoItemUiModel(
    val id: String,
    val planId: String,
    val title: String,
    val content: String,
    val isCompleted: Boolean,
    val triggerTime: LocalDateTime,
    val completedAt: LocalDateTime?,
    val createdAt: LocalDateTime,
    val formattedTime: String = "",
    val formattedDate: String = "",
    val timeAgo: String = "", // 相对时间显示，如"2小时前"
    val isOverdue: Boolean = false
)
```

### 2.3 创建周历模型
```kotlin
// domain/model/WeekCalendarModel.kt
data class WeekCalendarModel(
    val days: List<DayModel>,
    val weekRange: String, // 如 "2024年1月1日 - 1月7日"
    val currentWeekOffset: Int = 0 // 相对于当前周的偏移量
)

data class DayModel(
    val date: LocalDate,
    val dayOfWeek: String, // 如 "周一"
    val dayOfMonth: Int,
    val isToday: Boolean,
    val isCurrentMonth: Boolean,
    val todoItems: List<TodoItemUiModel> = emptyList(),
    val plans: List<PlanUiModel> = emptyList(),
    val hasEvents: Boolean = false
)
```

### 2.4 创建重复规则模型
```kotlin
// domain/model/RepeatRule.kt
data class RepeatRule(
    val type: RepeatType,
    val interval: Int = 1,
    val endDate: LocalDateTime? = null,
    val maxOccurrences: Int? = null,
    val daysOfWeek: Set<DayOfWeek> = emptySet(), // 周重复时指定星期几
    val dayOfMonth: Int? = null, // 月重复时指定几号
    val monthOfYear: Int? = null // 年重复时指定几月
) {
    fun getNextTriggerTime(currentTime: LocalDateTime): LocalDateTime? {
        return when (type) {
            RepeatType.NONE -> null
            RepeatType.DAILY -> currentTime.plusDays(interval.toLong())
            RepeatType.WEEKLY -> currentTime.plusWeeks(interval.toLong())
            RepeatType.MONTHLY -> currentTime.plusMonths(interval.toLong())
            RepeatType.YEARLY -> currentTime.plusYears(interval.toLong())
            RepeatType.CUSTOM -> calculateCustomRepeat(currentTime)
        }
    }

    private fun calculateCustomRepeat(currentTime: LocalDateTime): LocalDateTime? {
        // 自定义重复逻辑实现
        return when {
            daysOfWeek.isNotEmpty() -> calculateWeeklyCustom(currentTime)
            dayOfMonth != null -> calculateMonthlyCustom(currentTime)
            monthOfYear != null -> calculateYearlyCustom(currentTime)
            else -> null
        }
    }

    private fun calculateWeeklyCustom(currentTime: LocalDateTime): LocalDateTime {
        // 实现每周特定几天的重复逻辑
        val currentDayOfWeek = currentTime.dayOfWeek
        val nextDay = daysOfWeek.firstOrNull { it > currentDayOfWeek }
            ?: daysOfWeek.minOrNull()

        return if (nextDay != null && nextDay > currentDayOfWeek) {
            currentTime.with(nextDay)
        } else {
            currentTime.plusWeeks(1).with(nextDay ?: DayOfWeek.MONDAY)
        }
    }

    private fun calculateMonthlyCustom(currentTime: LocalDateTime): LocalDateTime {
        // 实现每月特定日期的重复逻辑
        val targetDay = dayOfMonth ?: return currentTime.plusMonths(1)
        return if (currentTime.dayOfMonth < targetDay) {
            currentTime.withDayOfMonth(targetDay)
        } else {
            currentTime.plusMonths(1).withDayOfMonth(targetDay)
        }
    }

    private fun calculateYearlyCustom(currentTime: LocalDateTime): LocalDateTime {
        // 实现每年特定月份的重复逻辑
        val targetMonth = monthOfYear ?: return currentTime.plusYears(1)
        val targetDay = dayOfMonth ?: currentTime.dayOfMonth
        return if (currentTime.monthValue < targetMonth) {
            currentTime.withMonth(targetMonth).withDayOfMonth(targetDay)
        } else {
            currentTime.plusYears(1).withMonth(targetMonth).withDayOfMonth(targetDay)
        }
    }
}
```

**依赖**: Kotlinx DateTime

## 3. 步骤二：创建数据转换器

### 3.1 创建模型转换器
```kotlin
// domain/model/ModelMapper.kt
object ModelMapper {

    fun Plan.toUiModel(userPreferences: UserPreferences): PlanUiModel {
        val triggerDateTime = Instant.fromEpochMilliseconds(triggerTime)
            .toLocalDateTime(TimeZone.currentSystemDefault())
        val createdDateTime = Instant.fromEpochMilliseconds(createdAt)
            .toLocalDateTime(TimeZone.currentSystemDefault())
        val updatedDateTime = Instant.fromEpochMilliseconds(updatedAt)
            .toLocalDateTime(TimeZone.currentSystemDefault())

        val repeatRule = RepeatRule(
            type = RepeatType.valueOf(repeatType),
            interval = repeatInterval
        )

        return PlanUiModel(
            id = id,
            title = title,
            content = content,
            triggerTime = triggerDateTime,
            isRepeating = isRepeating,
            repeatType = RepeatType.valueOf(repeatType),
            repeatInterval = repeatInterval,
            isActive = isActive,
            createdAt = createdDateTime,
            updatedAt = updatedDateTime,
            nextTriggerTime = if (isRepeating) repeatRule.getNextTriggerTime(triggerDateTime) else null,
            formattedTime = formatTime(triggerDateTime, userPreferences.timeFormat24Hour),
            formattedDate = formatDate(triggerDateTime),
            isOverdue = triggerDateTime < Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())
        )
    }

    fun PlanUiModel.toEntity(): Plan {
        return Plan(
            id = id,
            title = title,
            content = content,
            triggerTime = triggerTime.toInstant(TimeZone.currentSystemDefault()).toEpochMilliseconds(),
            isRepeating = isRepeating,
            repeatType = repeatType.name,
            repeatInterval = repeatInterval,
            isActive = isActive,
            createdAt = createdAt.toInstant(TimeZone.currentSystemDefault()).toEpochMilliseconds(),
            updatedAt = updatedAt.toInstant(TimeZone.currentSystemDefault()).toEpochMilliseconds()
        )
    }

    fun TodoItem.toUiModel(userPreferences: UserPreferences): TodoItemUiModel {
        val triggerDateTime = Instant.fromEpochMilliseconds(triggerTime)
            .toLocalDateTime(TimeZone.currentSystemDefault())
        val createdDateTime = Instant.fromEpochMilliseconds(createdAt)
            .toLocalDateTime(TimeZone.currentSystemDefault())
        val completedDateTime = completedAt?.let {
            Instant.fromEpochMilliseconds(it).toLocalDateTime(TimeZone.currentSystemDefault())
        }

        return TodoItemUiModel(
            id = id,
            planId = planId,
            title = title,
            content = content,
            isCompleted = isCompleted,
            triggerTime = triggerDateTime,
            completedAt = completedDateTime,
            createdAt = createdDateTime,
            formattedTime = formatTime(triggerDateTime, userPreferences.timeFormat24Hour),
            formattedDate = formatDate(triggerDateTime),
            timeAgo = calculateTimeAgo(triggerDateTime),
            isOverdue = !isCompleted && triggerDateTime < Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())
        )
    }

    fun TodoItemUiModel.toEntity(): TodoItem {
        return TodoItem(
            id = id,
            planId = planId,
            title = title,
            content = content,
            isCompleted = isCompleted,
            triggerTime = triggerTime.toInstant(TimeZone.currentSystemDefault()).toEpochMilliseconds(),
            completedAt = completedAt?.toInstant(TimeZone.currentSystemDefault())?.toEpochMilliseconds(),
            createdAt = createdAt.toInstant(TimeZone.currentSystemDefault()).toEpochMilliseconds()
        )
    }

    private fun formatTime(dateTime: LocalDateTime, is24Hour: Boolean): String {
        return if (is24Hour) {
            "${dateTime.hour.toString().padStart(2, '0')}:${dateTime.minute.toString().padStart(2, '0')}"
        } else {
            val hour = if (dateTime.hour == 0) 12 else if (dateTime.hour > 12) dateTime.hour - 12 else dateTime.hour
            val amPm = if (dateTime.hour < 12) "AM" else "PM"
            "${hour}:${dateTime.minute.toString().padStart(2, '0')} $amPm"
        }
    }

    private fun formatDate(dateTime: LocalDateTime): String {
        return "${dateTime.year}年${dateTime.monthNumber}月${dateTime.dayOfMonth}日"
    }

    private fun calculateTimeAgo(dateTime: LocalDateTime): String {
        val now = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())
        val duration = now.toInstant(TimeZone.currentSystemDefault()) -
                      dateTime.toInstant(TimeZone.currentSystemDefault())

        return when {
            duration.inWholeMinutes < 1 -> "刚刚"
            duration.inWholeMinutes < 60 -> "${duration.inWholeMinutes}分钟前"
            duration.inWholeHours < 24 -> "${duration.inWholeHours}小时前"
            duration.inWholeDays < 7 -> "${duration.inWholeDays}天前"
            duration.inWholeDays < 30 -> "${duration.inWholeDays / 7}周前"
            duration.inWholeDays < 365 -> "${duration.inWholeDays / 30}个月前"
            else -> "${duration.inWholeDays / 365}年前"
        }
    }
}
```

**依赖**: Kotlinx DateTime

## 4. 步骤三：创建用例 (UseCase)

### 4.1 计划管理用例
```kotlin
// domain/usecase/plan/CreatePlanUseCase.kt
@Singleton
class CreatePlanUseCase @Inject constructor(
    private val planRepository: PlanRepository
) {
    suspend operator fun invoke(
        title: String,
        content: String,
        triggerTime: LocalDateTime,
        isRepeating: Boolean = false,
        repeatType: RepeatType = RepeatType.NONE,
        repeatInterval: Int = 1
    ): Result<String> {
        return try {
            // 验证输入
            if (title.isBlank()) {
                return Result.failure(IllegalArgumentException("标题不能为空"))
            }
            if (content.isBlank()) {
                return Result.failure(IllegalArgumentException("内容不能为空"))
            }
            if (triggerTime <= Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())) {
                return Result.failure(IllegalArgumentException("提醒时间必须在未来"))
            }

            val plan = Plan(
                title = title.trim(),
                content = content.trim(),
                triggerTime = triggerTime.toInstant(TimeZone.currentSystemDefault()).toEpochMilliseconds(),
                isRepeating = isRepeating,
                repeatType = repeatType.name,
                repeatInterval = if (isRepeating) repeatInterval else 1
            )

            planRepository.insertPlan(plan)
            Result.success(plan.id)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

// domain/usecase/plan/UpdatePlanUseCase.kt
@Singleton
class UpdatePlanUseCase @Inject constructor(
    private val planRepository: PlanRepository
) {
    suspend operator fun invoke(planUiModel: PlanUiModel): Result<Unit> {
        return try {
            // 验证输入
            if (planUiModel.title.isBlank()) {
                return Result.failure(IllegalArgumentException("标题不能为空"))
            }
            if (planUiModel.content.isBlank()) {
                return Result.failure(IllegalArgumentException("内容不能为空"))
            }

            val plan = planUiModel.toEntity()
            planRepository.updatePlan(plan)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

// domain/usecase/plan/DeletePlanUseCase.kt
@Singleton
class DeletePlanUseCase @Inject constructor(
    private val planRepository: PlanRepository,
    private val todoItemRepository: TodoItemRepository
) {
    suspend operator fun invoke(planId: String): Result<Unit> {
        return try {
            // 删除相关的待办事项
            todoItemRepository.deleteTodoItemsByPlanId(planId)
            // 删除计划
            planRepository.deletePlanById(planId)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

// domain/usecase/plan/GetPlansUseCase.kt
@Singleton
class GetPlansUseCase @Inject constructor(
    private val planRepository: PlanRepository,
    private val userPreferencesDataStore: UserPreferencesDataStore
) {
    operator fun invoke(): Flow<List<PlanUiModel>> {
        return combine(
            planRepository.getAllPlans(),
            userPreferencesDataStore.userPreferences
        ) { plans, preferences ->
            plans.map { it.toUiModel(preferences) }
        }
    }

    fun getActivePlans(): Flow<List<PlanUiModel>> {
        return combine(
            planRepository.getActivePlans(),
            userPreferencesDataStore.userPreferences
        ) { plans, preferences ->
            plans.map { it.toUiModel(preferences) }
        }
    }

    fun getPlansForWeek(weekOffset: Int = 0): Flow<List<PlanUiModel>> {
        val now = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())
        val startOfWeek = now.plusDays((weekOffset * 7).toLong()).let { date ->
            date.minus(DatePeriod(days = date.dayOfWeek.ordinal))
        }
        val endOfWeek = startOfWeek.plusDays(6)

        val startTime = startOfWeek.toInstant(TimeZone.currentSystemDefault()).toEpochMilliseconds()
        val endTime = endOfWeek.toInstant(TimeZone.currentSystemDefault()).toEpochMilliseconds()

        return combine(
            planRepository.getPlansInTimeRange(startTime, endTime),
            userPreferencesDataStore.userPreferences
        ) { plans, preferences ->
            plans.map { it.toUiModel(preferences) }
        }
    }
}
```

### 4.2 待办事项管理用例
```kotlin
// domain/usecase/todo/CreateTodoItemUseCase.kt
@Singleton
class CreateTodoItemUseCase @Inject constructor(
    private val todoItemRepository: TodoItemRepository
) {
    suspend operator fun invoke(
        planId: String,
        title: String,
        content: String,
        triggerTime: LocalDateTime
    ): Result<String> {
        return try {
            val todoItem = TodoItem(
                planId = planId,
                title = title,
                content = content,
                triggerTime = triggerTime.toInstant(TimeZone.currentSystemDefault()).toEpochMilliseconds()
            )

            todoItemRepository.insertTodoItem(todoItem)
            Result.success(todoItem.id)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

// domain/usecase/todo/CompleteTodoItemUseCase.kt
@Singleton
class CompleteTodoItemUseCase @Inject constructor(
    private val todoItemRepository: TodoItemRepository
) {
    suspend operator fun invoke(todoItemId: String): Result<Unit> {
        return try {
            todoItemRepository.updateTodoItemCompletionStatus(todoItemId, true)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

// domain/usecase/todo/GetTodoItemsUseCase.kt
@Singleton
class GetTodoItemsUseCase @Inject constructor(
    private val todoItemRepository: TodoItemRepository,
    private val userPreferencesDataStore: UserPreferencesDataStore
) {
    fun getPendingTodoItems(): Flow<List<TodoItemUiModel>> {
        return combine(
            todoItemRepository.getPendingTodoItems(),
            userPreferencesDataStore.userPreferences
        ) { todoItems, preferences ->
            todoItems.map { it.toUiModel(preferences) }
        }
    }

    fun getCompletedTodoItems(): Flow<List<TodoItemUiModel>> {
        return combine(
            todoItemRepository.getCompletedTodoItems(),
            userPreferencesDataStore.userPreferences
        ) { todoItems, preferences ->
            todoItems.map { it.toUiModel(preferences) }
        }
    }

    fun getTodoItemsForWeek(weekOffset: Int = 0): Flow<List<TodoItemUiModel>> {
        val now = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())
        val startOfWeek = now.plusDays((weekOffset * 7).toLong()).let { date ->
            date.minus(DatePeriod(days = date.dayOfWeek.ordinal))
        }
        val endOfWeek = startOfWeek.plusDays(6)

        val startTime = startOfWeek.toInstant(TimeZone.currentSystemDefault()).toEpochMilliseconds()
        val endTime = endOfWeek.toInstant(TimeZone.currentSystemDefault()).toEpochMilliseconds()

        return combine(
            todoItemRepository.getTodoItemsInTimeRange(startTime, endTime),
            userPreferencesDataStore.userPreferences
        ) { todoItems, preferences ->
            todoItems.map { it.toUiModel(preferences) }
        }
    }
}
```

### 4.3 周历用例
```kotlin
// domain/usecase/calendar/GetWeekCalendarUseCase.kt
@Singleton
class GetWeekCalendarUseCase @Inject constructor(
    private val getPlansUseCase: GetPlansUseCase,
    private val getTodoItemsUseCase: GetTodoItemsUseCase,
    private val userPreferencesDataStore: UserPreferencesDataStore
) {
    operator fun invoke(weekOffset: Int = 0): Flow<WeekCalendarModel> {
        return combine(
            getPlansUseCase.getPlansForWeek(weekOffset),
            getTodoItemsUseCase.getTodoItemsForWeek(weekOffset),
            userPreferencesDataStore.userPreferences
        ) { plans, todoItems, preferences ->
            createWeekCalendarModel(plans, todoItems, weekOffset, preferences)
        }
    }

    private fun createWeekCalendarModel(
        plans: List<PlanUiModel>,
        todoItems: List<TodoItemUiModel>,
        weekOffset: Int,
        preferences: UserPreferences
    ): WeekCalendarModel {
        val now = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())
        val startOfWeek = now.plusDays((weekOffset * 7).toLong()).let { date ->
            date.minus(DatePeriod(days = date.dayOfWeek.ordinal))
        }

        val days = (0..6).map { dayOffset ->
            val date = startOfWeek.plusDays(dayOffset.toLong())
            val dayPlans = plans.filter {
                it.triggerTime.date == date.date
            }
            val dayTodoItems = todoItems.filter {
                it.triggerTime.date == date.date
            }

            DayModel(
                date = date.date,
                dayOfWeek = getDayOfWeekName(date.dayOfWeek),
                dayOfMonth = date.dayOfMonth,
                isToday = date.date == now.date,
                isCurrentMonth = date.monthNumber == now.monthNumber,
                todoItems = dayTodoItems,
                plans = dayPlans,
                hasEvents = dayPlans.isNotEmpty() || dayTodoItems.isNotEmpty()
            )
        }

        val weekRange = "${startOfWeek.year}年${startOfWeek.monthNumber}月${startOfWeek.dayOfMonth}日 - " +
                       "${startOfWeek.plusDays(6).monthNumber}月${startOfWeek.plusDays(6).dayOfMonth}日"

        return WeekCalendarModel(
            days = days,
            weekRange = weekRange,
            currentWeekOffset = weekOffset
        )
    }

    private fun getDayOfWeekName(dayOfWeek: DayOfWeek): String {
        return when (dayOfWeek) {
            DayOfWeek.MONDAY -> "周一"
            DayOfWeek.TUESDAY -> "周二"
            DayOfWeek.WEDNESDAY -> "周三"
            DayOfWeek.THURSDAY -> "周四"
            DayOfWeek.FRIDAY -> "周五"
            DayOfWeek.SATURDAY -> "周六"
            DayOfWeek.SUNDAY -> "周日"
        }
    }
}
```

**依赖**: Coroutines, Kotlinx DateTime

## 5. 步骤四：创建验证器

### 5.1 输入验证器
```kotlin
// domain/usecase/validation/InputValidator.kt
object InputValidator {

    fun validatePlanTitle(title: String): ValidationResult {
        return when {
            title.isBlank() -> ValidationResult.Error("标题不能为空")
            title.length > 100 -> ValidationResult.Error("标题不能超过100个字符")
            else -> ValidationResult.Success
        }
    }

    fun validatePlanContent(content: String): ValidationResult {
        return when {
            content.isBlank() -> ValidationResult.Error("内容不能为空")
            content.length > 500 -> ValidationResult.Error("内容不能超过500个字符")
            else -> ValidationResult.Success
        }
    }

    fun validateTriggerTime(triggerTime: LocalDateTime): ValidationResult {
        val now = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())
        return when {
            triggerTime <= now -> ValidationResult.Error("提醒时间必须在未来")
            triggerTime > now.plusYears(10) -> ValidationResult.Error("提醒时间不能超过10年")
            else -> ValidationResult.Success
        }
    }

    fun validateRepeatInterval(interval: Int, repeatType: RepeatType): ValidationResult {
        return when {
            interval <= 0 -> ValidationResult.Error("重复间隔必须大于0")
            repeatType == RepeatType.DAILY && interval > 365 -> ValidationResult.Error("每日重复间隔不能超过365天")
            repeatType == RepeatType.WEEKLY && interval > 52 -> ValidationResult.Error("每周重复间隔不能超过52周")
            repeatType == RepeatType.MONTHLY && interval > 12 -> ValidationResult.Error("每月重复间隔不能超过12个月")
            repeatType == RepeatType.YEARLY && interval > 10 -> ValidationResult.Error("每年重复间隔不能超过10年")
            else -> ValidationResult.Success
        }
    }

    sealed class ValidationResult {
        object Success : ValidationResult()
        data class Error(val message: String) : ValidationResult()
    }
}
```

## 6. 步骤五：创建业务异常

### 6.1 自定义异常类
```kotlin
// domain/exception/BusinessException.kt
sealed class BusinessException(message: String, cause: Throwable? = null) : Exception(message, cause) {

    class PlanNotFoundException(planId: String) : BusinessException("计划不存在: $planId")

    class TodoItemNotFoundException(todoItemId: String) : BusinessException("待办事项不存在: $todoItemId")

    class InvalidInputException(message: String) : BusinessException("输入无效: $message")

    class AlarmPermissionException : BusinessException("缺少闹钟权限")

    class NotificationPermissionException : BusinessException("缺少通知权限")

    class DatabaseException(message: String, cause: Throwable) : BusinessException("数据库错误: $message", cause)

    class NetworkException(message: String, cause: Throwable) : BusinessException("网络错误: $message", cause)
}
```

## 7. 步骤六：创建结果包装器

### 7.1 操作结果封装
```kotlin
// domain/model/OperationResult.kt
sealed class OperationResult<out T> {
    data class Success<T>(val data: T) : OperationResult<T>()
    data class Error(val exception: Throwable) : OperationResult<Nothing>()
    object Loading : OperationResult<Nothing>()

    fun isSuccess(): Boolean = this is Success
    fun isError(): Boolean = this is Error
    fun isLoading(): Boolean = this is Loading

    fun getOrNull(): T? = if (this is Success) data else null
    fun getErrorOrNull(): Throwable? = if (this is Error) exception else null

    inline fun onSuccess(action: (T) -> Unit): OperationResult<T> {
        if (this is Success) action(data)
        return this
    }

    inline fun onError(action: (Throwable) -> Unit): OperationResult<T> {
        if (this is Error) action(exception)
        return this
    }

    inline fun onLoading(action: () -> Unit): OperationResult<T> {
        if (this is Loading) action()
        return this
    }
}

// 扩展函数
fun <T> Flow<T>.asOperationResult(): Flow<OperationResult<T>> = flow {
    emit(OperationResult.Loading)
    try {
        collect { value ->
            emit(OperationResult.Success(value))
        }
    } catch (e: Throwable) {
        emit(OperationResult.Error(e))
    }
}
```

## 8. 步骤七：创建业务逻辑处理器

### 8.1 重复计划处理器
```kotlin
// domain/usecase/repeat/RepeatPlanProcessor.kt
@Singleton
class RepeatPlanProcessor @Inject constructor(
    private val planRepository: PlanRepository,
    private val todoItemRepository: TodoItemRepository
) {
    suspend fun processTriggeredPlan(planId: String): Result<Unit> {
        return try {
            val plan = planRepository.getPlanById(planId)
                ?: return Result.failure(BusinessException.PlanNotFoundException(planId))

            // 创建待办事项
            val todoItem = TodoItem(
                planId = plan.id,
                title = plan.title,
                content = plan.content,
                triggerTime = plan.triggerTime
            )
            todoItemRepository.insertTodoItem(todoItem)

            // 如果是重复计划，计算下次触发时间并更新
            if (plan.isRepeating) {
                val repeatRule = RepeatRule(
                    type = RepeatType.valueOf(plan.repeatType),
                    interval = plan.repeatInterval
                )
                val currentTime = Instant.fromEpochMilliseconds(plan.triggerTime)
                    .toLocalDateTime(TimeZone.currentSystemDefault())
                val nextTriggerTime = repeatRule.getNextTriggerTime(currentTime)

                if (nextTriggerTime != null) {
                    val updatedPlan = plan.copy(
                        triggerTime = nextTriggerTime.toInstant(TimeZone.currentSystemDefault()).toEpochMilliseconds(),
                        updatedAt = System.currentTimeMillis()
                    )
                    planRepository.updatePlan(updatedPlan)
                } else {
                    // 如果没有下次触发时间，停用计划
                    planRepository.updatePlanActiveStatus(plan.id, false)
                }
            } else {
                // 非重复计划，触发后停用
                planRepository.updatePlanActiveStatus(plan.id, false)
            }

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    suspend fun getUpcomingPlans(hoursAhead: Int = 24): List<Plan> {
        val now = Clock.System.now()
        val futureTime = now.plus(hoursAhead, DateTimeUnit.HOUR)

        return planRepository.getPlansInTimeRange(
            now.toEpochMilliseconds(),
            futureTime.toEpochMilliseconds()
        ).first()
    }
}
```

### 8.2 数据同步处理器
```kotlin
// domain/usecase/sync/DataSyncProcessor.kt
@Singleton
class DataSyncProcessor @Inject constructor(
    private val planRepository: PlanRepository,
    private val todoItemRepository: TodoItemRepository
) {
    suspend fun cleanupOldData(): Result<Unit> {
        return try {
            val thirtyDaysAgo = Clock.System.now()
                .minus(30, DateTimeUnit.DAY)
                .toEpochMilliseconds()

            // 清理30天前的已完成待办事项
            val oldCompletedTodos = todoItemRepository.getCompletedTodoItems().first()
                .filter { it.completedAt != null && it.completedAt < thirtyDaysAgo }

            oldCompletedTodos.forEach { todoItem ->
                todoItemRepository.deleteTodoItem(todoItem)
            }

            // 清理已停用且无关联待办事项的计划
            val inactivePlans = planRepository.getAllPlans().first()
                .filter { !it.isActive }

            inactivePlans.forEach { plan ->
                val relatedTodos = todoItemRepository.getTodoItemsByPlanId(plan.id).first()
                if (relatedTodos.isEmpty()) {
                    planRepository.deletePlan(plan)
                }
            }

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    suspend fun validateDataIntegrity(): Result<List<String>> {
        return try {
            val issues = mutableListOf<String>()

            // 检查孤立的待办事项
            val allTodos = todoItemRepository.getAllTodoItems().first()
            val allPlans = planRepository.getAllPlans().first()
            val planIds = allPlans.map { it.id }.toSet()

            val orphanedTodos = allTodos.filter { it.planId !in planIds }
            if (orphanedTodos.isNotEmpty()) {
                issues.add("发现 ${orphanedTodos.size} 个孤立的待办事项")
                // 清理孤立的待办事项
                orphanedTodos.forEach { todoItemRepository.deleteTodoItem(it) }
            }

            // 检查过期的活跃计划
            val now = Clock.System.now().toEpochMilliseconds()
            val expiredActivePlans = allPlans.filter {
                it.isActive && !it.isRepeating && it.triggerTime < now
            }
            if (expiredActivePlans.isNotEmpty()) {
                issues.add("发现 ${expiredActivePlans.size} 个已过期但仍活跃的计划")
                // 停用过期的非重复计划
                expiredActivePlans.forEach { plan ->
                    planRepository.updatePlanActiveStatus(plan.id, false)
                }
            }

            Result.success(issues)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

**依赖**: Coroutines, Kotlinx DateTime

## 9. 测试用例

### 9.1 UseCase 单元测试示例
```kotlin
// 在测试章节中详细说明
```

## 10. 验证步骤

### 10.1 编译验证
```bash
./gradlew assembleDebug
```

### 10.2 业务逻辑测试
- 创建单元测试验证各个 UseCase 的逻辑
- 验证数据转换的正确性
- 测试异常处理机制

## 11. 下一步

业务层开发完成后，可以继续：
1. UI层开发（参考 `05-UI层开发.md`）
2. 系统集成开发（参考 `06-系统集成开发.md`）

## 12. 常见问题

### 12.1 时间处理
- 统一使用 Kotlinx DateTime
- 注意时区转换问题
- 正确处理夏令时

### 12.2 数据一致性
- 使用事务确保数据一致性
- 实现数据验证和清理机制
- 处理并发访问问题

### 12.3 性能优化
- 合理使用 Flow 和缓存
- 避免在主线程执行耗时操作
- 优化数据库查询