# 自动反复提醒功能变更方案

## 1. 变更概述

### 1.1 当前功能
- **稍后提醒功能**：用户手动点击"稍后提醒"按钮，将提醒延迟5分钟后再次显示
- **实现方式**：通过NotificationActionReceiver处理ACTION_SNOOZE_TODO广播

### 1.2 变更目标
- **自动反复提醒功能**：如果用户在30分钟内没有将TodoItem标记为完成，系统自动重新发送通知
- **取消手动稍后提醒**：移除"稍后提醒"按钮和相关处理逻辑

## 2. 功能设计

### 2.1 核心逻辑
1. **首次提醒**：按原计划时间发送通知
2. **检查完成状态**：发送通知后开始计时
3. **自动重发**：30分钟后检查TodoItem是否已完成
   - 如果未完成：重新发送通知
   - 如果已完成：停止提醒
4. **重复次数限制**：最多重复提醒3次，避免无限循环

### 2.2 状态流转
```
首次提醒 → [30分钟] → 检查完成状态 → 未完成 → 第二次提醒 → [30分钟] → 检查完成状态 → 未完成 → 第三次提醒 → [30分钟] → 检查完成状态 → 未完成 → 停止提醒
```

## 3. 技术实现方案

### 3.1 数据模型变更

#### 3.1.1 TodoItem模型扩展
在`TodoItem`数据模型中添加以下字段：

```kotlin
data class TodoItem(
    val id: String,
    val planId: String,
    val title: String,
    val content: String,
    val isCompleted: Boolean = false,
    val triggerTime: LocalDateTime,
    val completedAt: LocalDateTime? = null,
    val createdAt: LocalDateTime,
    // 新增字段
    val reminderCount: Int = 0,           // 已提醒次数
    val maxReminderCount: Int = 3,        // 最大提醒次数
    val reminderIntervalMinutes: Int = 30, // 提醒间隔分钟数
    val nextReminderTime: LocalDateTime? = null // 下次提醒时间
)
```

### 3.2 业务逻辑变更

#### 3.2.1 通知发送逻辑
在`NotificationManagerImpl.showAlarmNotification()`中：
- 发送通知后，立即调度下一次提醒检查
- 更新TodoItem的`reminderCount`和`nextReminderTime`

#### 3.2.2 自动提醒调度器
创建新的`AutoReminderScheduler`类：

```kotlin
interface AutoReminderScheduler {
    /**
     * 调度自动反复提醒
     */
    fun scheduleAutoReminder(todoItem: TodoItem)

    /**
     * 取消自动反复提醒
     */
    fun cancelAutoReminder(todoItemId: String)

    /**
     * 处理提醒检查
     */
    suspend fun handleReminderCheck(todoItemId: String)
}
```

### 3.3 系统集成变更

#### 3.3.1 移除稍后提醒功能
1. **NotificationManagerImpl**：移除"稍后提醒"按钮和相关PendingIntent
2. **NotificationActionReceiver**：移除`ACTION_SNOOZE_TODO`和`handleSnoozeTodo()`方法

#### 3.3.2 新增自动提醒接收器
创建`AutoReminderReceiver`：

```kotlin
class AutoReminderReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val todoItemId = intent.getStringExtra(EXTRA_TODO_ITEM_ID) ?: return

        // 使用goAsync()处理异步操作
        val pendingResult = goAsync()

        CoroutineScope(Dispatchers.IO).launch {
            try {
                autoReminderScheduler.handleReminderCheck(todoItemId)
            } finally {
                pendingResult.finish()
            }
        }
    }
}
```

### 3.4 核心算法

#### 3.4.1 自动提醒检查逻辑
```kotlin
private suspend fun handleReminderCheck(todoItemId: String) {
    val todoItem = todoRepository.getTodoItemById(todoItemId)
    todoItem?.let { todo ->
        when {
            // 如果已完成，停止提醒
            todo.isCompleted -> {
                cancelAutoReminder(todo.id)
            }
            // 如果未达到最大提醒次数，重新发送通知
            todo.reminderCount < todo.maxReminderCount -> {
                // 更新提醒次数
                val updatedTodo = todo.copy(
                    reminderCount = todo.reminderCount + 1,
                    nextReminderTime = calculateNextReminderTime(todo)
                )
                todoRepository.updateTodoItem(updatedTodo)

                // 重新发送通知
                notificationManager.showAlarmNotification(updatedTodo)

                // 调度下一次检查
                scheduleAutoReminder(updatedTodo)
            }
            // 达到最大提醒次数，停止提醒
            else -> {
                cancelAutoReminder(todo.id)
                // 可选：发送最后一次提醒，告知用户已达到最大提醒次数
                notificationManager.showAlarmNotification(todo.copy(
                    content = "${todo.content}\n\n(已达到最大提醒次数)"
                ))
            }
        }
    }
}
```

#### 3.4.2 下次提醒时间计算
```kotlin
private fun calculateNextReminderTime(todoItem: TodoItem): LocalDateTime {
    val timeZone = TimeZone.currentSystemDefault()
    val instant = Clock.System.now().toInstant(timeZone)
    val nextInstant = instant.plus(todoItem.reminderIntervalMinutes, DateTimeUnit.MINUTE, timeZone)
    return nextInstant.toLocalDateTime(timeZone)
}
```

## 4. 实施步骤

### 4.1 第一阶段：数据模型变更
1. 更新`TodoItem`数据模型，添加自动提醒相关字段
2. 更新数据库迁移脚本
3. 更新相关数据访问层代码

### 4.2 第二阶段：业务逻辑实现
1. 实现`AutoReminderScheduler`接口和实现类
2. 创建`AutoReminderReceiver`
3. 更新依赖注入配置

### 4.3 第三阶段：UI和通知变更
1. 移除通知中的"稍后提醒"按钮
2. 更新`NotificationManagerImpl`
3. 移除`NotificationActionReceiver`中的稍后提醒逻辑

### 4.4 第四阶段：集成测试
1. 测试自动反复提醒功能
2. 测试完成状态检查
3. 测试最大提醒次数限制

## 5. 配置参数

### 5.1 可配置参数
- **提醒间隔**：默认30分钟，可在应用设置中调整
- **最大提醒次数**：默认3次，可在应用设置中调整
- **首次提醒时间**：按原计划时间

### 5.2 配置存储
使用`UserPreferencesDataStore`存储用户配置：
```kotlin
data class AutoReminderPreferences(
    val enabled: Boolean = true,
    val intervalMinutes: Int = 30,
    val maxCount: Int = 3
)
```

## 6. 用户体验

### 6.1 通知内容优化
- 首次提醒："待办事项：{标题}"
- 后续提醒："待办事项（第{次数}次提醒）：{标题}"
- 最后一次提醒："待办事项（最后一次提醒）：{标题}"

### 6.2 设置界面
在应用设置中添加自动反复提醒配置：
- 开关：启用/禁用自动反复提醒
- 间隔设置：15分钟/30分钟/1小时
- 次数设置：1次/3次/5次

## 7. 技术优势

### 7.1 相比手动稍后提醒的优势
1. **自动化**：无需用户手动操作
2. **智能判断**：基于完成状态自动决策
3. **可控性**：可配置间隔和次数
4. **防骚扰**：有最大次数限制

### 7.2 系统资源优化
- 使用AlarmManager进行精确调度
- 及时取消已完成事项的提醒
- 避免不必要的系统唤醒

## 8. 风险评估

### 8.1 技术风险
- **数据迁移**：需要处理现有数据的兼容性
- **系统权限**：需要精确闹钟权限
- **电池影响**：频繁调度可能影响电池寿命

### 8.2 缓解措施
- 提供配置选项让用户控制提醒频率
- 使用批处理减少系统唤醒次数
- 提供详细的电量使用说明

## 9. 后续优化

### 9.1 智能提醒
- 基于用户行为模式调整提醒策略
- 学习用户处理待办事项的习惯时间

### 9.2 多渠道提醒
- 结合系统通知、声音、震动等多种方式
- 支持重要事项的紧急提醒模式

这个变更方案将显著提升用户体验，从被动的手动操作转变为智能的自动提醒，同时保持对系统资源的合理使用。