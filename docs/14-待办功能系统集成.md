# 定时提醒小助手 - 待办功能系统集成

## 1. 概述

本文档描述待办功能与系统组件的集成方案，包括通知系统、闹钟管理、后台任务处理和权限管理。

## 2. 系统架构集成

### 2.1 整体集成架构

```
┌─────────────────────────────────────────┐
│              Application                │
├─────────────────────────────────────────┤
│           Todo Feature                  │
│  ┌─────────────┐  ┌─────────────┐       │
│  │ TodoService │  │ TodoWorker  │       │
│  └─────────────┘  └─────────────┘       │
├─────────────────────────────────────────┤
│          System Integration             │
│  ┌─────────────┐  ┌─────────────┐       │
│  │AlarmManager │  │Notification │       │
│  └─────────────┘  └─────────────┘       │
├─────────────────────────────────────────┤
│           Android System                │
└─────────────────────────────────────────┘
```

## 3. 通知系统集成

### 3.1 通知管理器

```kotlin
// system/notification/TodoNotificationManager.kt
@Singleton
class TodoNotificationManager @Inject constructor(
    @ApplicationContext private val context: Context
) {

    companion object {
        const val CHANNEL_ID = "todo_reminders"
        const val CHANNEL_NAME = "待办提醒"
        const val NOTIFICATION_ID_BASE = 10000
    }

    init {
        createNotificationChannel()
    }

    private fun createNotificationChannel() {
        val channel = NotificationChannel(
            CHANNEL_ID,
            CHANNEL_NAME,
            NotificationManager.IMPORTANCE_HIGH
        ).apply {
            description = "待办事项提醒通知"
            enableVibration(true)
            enableLights(true)
            lightColor = Color.BLUE
            setSound(RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION), null)
        }

        val notificationManager = context.getSystemService(NotificationManager::class.java)
        notificationManager.createNotificationChannel(channel)
    }

    fun scheduleNotification(todoItem: TodoItem) {
        val alarmManager = context.getSystemService(AlarmManager::class.java)
        val intent = createNotificationIntent(todoItem)
        val pendingIntent = PendingIntent.getBroadcast(
            context,
            todoItem.id.hashCode(),
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        // 设置精确闹钟
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            if (alarmManager.canScheduleExactAlarms()) {
                alarmManager.setExactAndAllowWhileIdle(
                    AlarmManager.RTC_WAKEUP,
                    todoItem.triggerTime,
                    pendingIntent
                )
            } else {
                // 请求精确闹钟权限
                requestExactAlarmPermission()
            }
        } else {
            alarmManager.setExactAndAllowWhileIdle(
                AlarmManager.RTC_WAKEUP,
                todoItem.triggerTime,
                pendingIntent
            )
        }
    }

    fun cancelNotification(todoItem: TodoItem) {
        val alarmManager = context.getSystemService(AlarmManager::class.java)
        val intent = createNotificationIntent(todoItem)
        val pendingIntent = PendingIntent.getBroadcast(
            context,
            todoItem.id.hashCode(),
            intent,
            PendingIntent.FLAG_NO_CREATE or PendingIntent.FLAG_IMMUTABLE
        )

        pendingIntent?.let {
            alarmManager.cancel(it)
            it.cancel()
        }
    }

    fun showNotification(todoItem: TodoItem) {
        val notification = createNotification(todoItem)
        val notificationManager = context.getSystemService(NotificationManager::class.java)
        notificationManager.notify(
            NOTIFICATION_ID_BASE + todoItem.id.hashCode(),
            notification
        )
    }

    private fun createNotification(todoItem: TodoItem): Notification {
        // 点击通知的意图
        val clickIntent = Intent(context, MainActivity::class.java).apply {
            putExtra("todoId", todoItem.id)
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
        }
        val clickPendingIntent = PendingIntent.getActivity(
            context,
            todoItem.id.hashCode(),
            clickIntent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        // 完成按钮意图
        val completeIntent = Intent(context, TodoActionReceiver::class.java).apply {
            action = TodoActionReceiver.ACTION_COMPLETE
            putExtra("todoId", todoItem.id)
        }
        val completePendingIntent = PendingIntent.getBroadcast(
            context,
            todoItem.id.hashCode() + 1,
            completeIntent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        // 推迟按钮意图
        val snoozeIntent = Intent(context, TodoActionReceiver::class.java).apply {
            action = TodoActionReceiver.ACTION_SNOOZE
            putExtra("todoId", todoItem.id)
        }
        val snoozePendingIntent = PendingIntent.getBroadcast(
            context,
            todoItem.id.hashCode() + 2,
            snoozeIntent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        return NotificationCompat.Builder(context, CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle(todoItem.title)
            .setContentText(todoItem.content)
            .setStyle(NotificationCompat.BigTextStyle().bigText(todoItem.content))
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setCategory(NotificationCompat.CATEGORY_REMINDER)
            .setAutoCancel(true)
            .setContentIntent(clickPendingIntent)
            .addAction(
                R.drawable.ic_check,
                "完成",
                completePendingIntent
            )
            .addAction(
                R.drawable.ic_snooze,
                "推迟",
                snoozePendingIntent
            )
            .build()
    }

    private fun createNotificationIntent(todoItem: TodoItem): Intent {
        return Intent(context, TodoAlarmReceiver::class.java).apply {
            action = TodoAlarmReceiver.ACTION_TODO_REMINDER
            putExtra("todoId", todoItem.id)
            putExtra("todoTitle", todoItem.title)
            putExtra("todoContent", todoItem.content)
        }
    }
}
```

### 3.2 闹钟接收器

```kotlin
// system/receiver/TodoAlarmReceiver.kt
class TodoAlarmReceiver : BroadcastReceiver() {

    companion object {
        const val ACTION_TODO_REMINDER = "com.todayalarm.TODO_REMINDER"
    }

    override fun onReceive(context: Context, intent: Intent) {
        when (intent.action) {
            ACTION_TODO_REMINDER -> {
                handleTodoReminder(context, intent)
            }
        }
    }

    private fun handleTodoReminder(context: Context, intent: Intent) {
        val todoId = intent.getStringExtra("todoId") ?: return
        val todoTitle = intent.getStringExtra("todoTitle") ?: return
        val todoContent = intent.getStringExtra("todoContent") ?: return

        // 启动后台服务处理待办提醒
        val serviceIntent = Intent(context, TodoReminderService::class.java).apply {
            putExtra("todoId", todoId)
            putExtra("todoTitle", todoTitle)
            putExtra("todoContent", todoContent)
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            context.startForegroundService(serviceIntent)
        } else {
            context.startService(serviceIntent)
        }
    }
}
```

### 3.3 操作接收器

```kotlin
// system/receiver/TodoActionReceiver.kt
class TodoActionReceiver : BroadcastReceiver() {

    companion object {
        const val ACTION_COMPLETE = "com.todayalarm.TODO_COMPLETE"
        const val ACTION_SNOOZE = "com.todayalarm.TODO_SNOOZE"
    }

    override fun onReceive(context: Context, intent: Intent) {
        val todoId = intent.getStringExtra("todoId") ?: return

        when (intent.action) {
            ACTION_COMPLETE -> {
                handleCompleteTodo(context, todoId)
            }
            ACTION_SNOOZE -> {
                handleSnoozeTodo(context, todoId)
            }
        }
    }

    private fun handleCompleteTodo(context: Context, todoId: String) {
        // 使用 WorkManager 处理完成操作
        val workRequest = OneTimeWorkRequestBuilder<CompleteTodoWorker>()
            .setInputData(workDataOf("todoId" to todoId))
            .build()

        WorkManager.getInstance(context).enqueue(workRequest)

        // 取消通知
        val notificationManager = context.getSystemService(NotificationManager::class.java)
        notificationManager.cancel(TodoNotificationManager.NOTIFICATION_ID_BASE + todoId.hashCode())
    }

    private fun handleSnoozeTodo(context: Context, todoId: String) {
        // 推迟15分钟
        val workRequest = OneTimeWorkRequestBuilder<SnoozeTodoWorker>()
            .setInputData(workDataOf(
                "todoId" to todoId,
                "snoozeMinutes" to 15
            ))
            .build()

        WorkManager.getInstance(context).enqueue(workRequest)

        // 取消当前通知
        val notificationManager = context.getSystemService(NotificationManager::class.java)
        notificationManager.cancel(TodoNotificationManager.NOTIFICATION_ID_BASE + todoId.hashCode())
    }
}
```

## 4. 后台任务处理

### 4.1 提醒服务

```kotlin
// system/service/TodoReminderService.kt
class TodoReminderService : Service() {

    private val notificationId = 1001

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val todoId = intent?.getStringExtra("todoId")
        val todoTitle = intent?.getStringExtra("todoTitle")
        val todoContent = intent?.getStringExtra("todoContent")

        if (todoId != null && todoTitle != null && todoContent != null) {
            startForeground(notificationId, createForegroundNotification())
            handleTodoReminder(todoId, todoTitle, todoContent)
        }

        return START_NOT_STICKY
    }

    private fun createForegroundNotification(): Notification {
        return NotificationCompat.Builder(this, TodoNotificationManager.CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle("处理待办提醒")
            .setContentText("正在处理待办事项提醒...")
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .build()
    }

    private fun handleTodoReminder(todoId: String, todoTitle: String, todoContent: String) {
        // 创建待办事项和显示通知的工作
        val workRequest = OneTimeWorkRequestBuilder<CreateTodoFromPlanWorker>()
            .setInputData(workDataOf(
                "todoId" to todoId,
                "todoTitle" to todoTitle,
                "todoContent" to todoContent
            ))
            .build()

        WorkManager.getInstance(this).enqueue(workRequest)

        stopSelf()
    }
}
```

### 4.2 Worker 类

```kotlin
// system/worker/CreateTodoFromPlanWorker.kt
@HiltWorker
class CreateTodoFromPlanWorker @AssistedInject constructor(
    @Assisted context: Context,
    @Assisted workerParams: WorkerParameters,
    private val todoRepository: TodoItemRepository,
    private val planRepository: PlanRepository,
    private val notificationManager: TodoNotificationManager
) : CoroutineWorker(context, workerParams) {

    override suspend fun doWork(): Result {
        return try {
            val planId = inputData.getString("planId") ?: return Result.failure()
            val triggerTime = inputData.getLong("triggerTime", 0L)

            // 获取计划信息
            val plan = planRepository.getPlanById(planId) ?: return Result.failure()

            // 创建待办事项
            val todoItem = TodoItemFactory.createFromPlan(plan, triggerTime)
            todoRepository.insertTodoItem(todoItem)

            // 显示通知
            notificationManager.showNotification(todoItem)

            Result.success()
        } catch (e: Exception) {
            Result.failure()
        }
    }

    @AssistedFactory
    interface Factory {
        fun create(context: Context, params: WorkerParameters): CreateTodoFromPlanWorker
    }
}

// system/worker/CompleteTodoWorker.kt
@HiltWorker
class CompleteTodoWorker @AssistedInject constructor(
    @Assisted context: Context,
    @Assisted workerParams: WorkerParameters,
    private val todoRepository: TodoItemRepository
) : CoroutineWorker(context, workerParams) {

    override suspend fun doWork(): Result {
        return try {
            val todoId = inputData.getString("todoId") ?: return Result.failure()
            todoRepository.completeTodoItem(todoId)
            Result.success()
        } catch (e: Exception) {
            Result.failure()
        }
    }

    @AssistedFactory
    interface Factory {
        fun create(context: Context, params: WorkerParameters): CompleteTodoWorker
    }
}
```

## 5. 权限管理

### 5.1 权限检查和请求

```kotlin
// system/permission/TodoPermissionManager.kt
@Singleton
class TodoPermissionManager @Inject constructor(
    @ApplicationContext private val context: Context
) {

    fun checkNotificationPermission(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            ContextCompat.checkSelfPermission(
                context,
                Manifest.permission.POST_NOTIFICATIONS
            ) == PackageManager.PERMISSION_GRANTED
        } else {
            NotificationManagerCompat.from(context).areNotificationsEnabled()
        }
    }

    fun checkExactAlarmPermission(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            val alarmManager = context.getSystemService(AlarmManager::class.java)
            alarmManager.canScheduleExactAlarms()
        } else {
            true
        }
    }

    fun requestNotificationPermission(activity: Activity) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            ActivityCompat.requestPermissions(
                activity,
                arrayOf(Manifest.permission.POST_NOTIFICATIONS),
                REQUEST_CODE_NOTIFICATION
            )
        } else {
            // 引导用户到设置页面
            val intent = Intent().apply {
                action = Settings.ACTION_APP_NOTIFICATION_SETTINGS
                putExtra(Settings.EXTRA_APP_PACKAGE, context.packageName)
            }
            activity.startActivity(intent)
        }
    }

    fun requestExactAlarmPermission(activity: Activity) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            val intent = Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM).apply {
                data = Uri.parse("package:${context.packageName}")
            }
            activity.startActivity(intent)
        }
    }

    companion object {
        const val REQUEST_CODE_NOTIFICATION = 1001
        const val REQUEST_CODE_EXACT_ALARM = 1002
    }
}
```

### 5.2 权限状态监听

```kotlin
// system/permission/PermissionStateObserver.kt
@Singleton
class PermissionStateObserver @Inject constructor(
    private val permissionManager: TodoPermissionManager
) {

    private val _permissionState = MutableStateFlow(PermissionState())
    val permissionState: StateFlow<PermissionState> = _permissionState.asStateFlow()

    fun checkPermissions() {
        _permissionState.value = PermissionState(
            hasNotificationPermission = permissionManager.checkNotificationPermission(),
            hasExactAlarmPermission = permissionManager.checkExactAlarmPermission()
        )
    }
}

data class PermissionState(
    val hasNotificationPermission: Boolean = false,
    val hasExactAlarmPermission: Boolean = false
) {
    val allPermissionsGranted: Boolean
        get() = hasNotificationPermission && hasExactAlarmPermission
}
```

## 6. 系统事件处理

### 6.1 设备重启处理

```kotlin
// system/receiver/BootReceiver.kt
class BootReceiver : BroadcastReceiver() {

    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Intent.ACTION_BOOT_COMPLETED) {
            // 设备重启后重新设置所有活跃的待办提醒
            val workRequest = OneTimeWorkRequestBuilder<RestoreAlarmsWorker>()
                .build()

            WorkManager.getInstance(context).enqueue(workRequest)
        }
    }
}

// system/worker/RestoreAlarmsWorker.kt
@HiltWorker
class RestoreAlarmsWorker @AssistedInject constructor(
    @Assisted context: Context,
    @Assisted workerParams: WorkerParameters,
    private val todoRepository: TodoItemRepository,
    private val notificationManager: TodoNotificationManager
) : CoroutineWorker(context, workerParams) {

    override suspend fun doWork(): Result {
        return try {
            // 获取所有未完成的待办事项
            val pendingTodos = todoRepository.getPendingTodoItems().first()

            // 重新设置提醒
            pendingTodos.forEach { todoItem ->
                if (todoItem.triggerTime > System.currentTimeMillis()) {
                    notificationManager.scheduleNotification(todoItem)
                }
            }

            Result.success()
        } catch (e: Exception) {
            Result.failure()
        }
    }

    @AssistedFactory
    interface Factory {
        fun create(context: Context, params: WorkerParameters): RestoreAlarmsWorker
    }
}
```

## 7. 应用生命周期集成

### 7.1 Application 类配置

```kotlin
// TodayAlarmApplication.kt
@HiltAndroidApp
class TodayAlarmApplication : Application() {

    @Inject
    lateinit var permissionStateObserver: PermissionStateObserver

    override fun onCreate() {
        super.onCreate()

        // 检查权限状态
        permissionStateObserver.checkPermissions()

        // 配置 WorkManager
        configureWorkManager()
    }

    private fun configureWorkManager() {
        val config = Configuration.Builder()
            .setWorkerFactory(HiltWorkerFactory())
            .build()

        WorkManager.initialize(this, config)
    }
}
```

### 7.2 MainActivity 集成

```kotlin
// MainActivity.kt
@AndroidEntryPoint
class MainActivity : ComponentActivity() {

    @Inject
    lateinit var permissionManager: TodoPermissionManager

    private val permissionLauncher = registerForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { isGranted ->
        if (!isGranted) {
            // 处理权限拒绝
            showPermissionDeniedDialog()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // 检查并请求必要权限
        checkAndRequestPermissions()

        // 处理通知点击
        handleNotificationClick(intent)

        setContent {
            TodayAlarmTheme {
                TodayAlarmApp()
            }
        }
    }

    override fun onNewIntent(intent: Intent?) {
        super.onNewIntent(intent)
        intent?.let { handleNotificationClick(it) }
    }

    private fun checkAndRequestPermissions() {
        if (!permissionManager.checkNotificationPermission()) {
            permissionManager.requestNotificationPermission(this)
        }

        if (!permissionManager.checkExactAlarmPermission()) {
            permissionManager.requestExactAlarmPermission(this)
        }
    }

    private fun handleNotificationClick(intent: Intent) {
        val todoId = intent.getStringExtra("todoId")
        if (todoId != null) {
            // 导航到待办详情
            // 实现导航逻辑
        }
    }
}
```

## 8. 配置文件

### 8.1 AndroidManifest.xml

```xml
<!-- 权限声明 -->
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
<uses-permission android:name="android.permission.WAKE_LOCK" />
<uses-permission android:name="android.permission.VIBRATE" />
<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
<uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />
<uses-permission android:name="android.permission.USE_EXACT_ALARM" />

<application>
    <!-- 服务声明 -->
    <service
        android:name=".system.service.TodoReminderService"
        android:enabled="true"
        android:exported="false"
        android:foregroundServiceType="shortService" />

    <!-- 接收器声明 -->
    <receiver
        android:name=".system.receiver.BootReceiver"
        android:enabled="true"
        android:exported="true">
        <intent-filter android:priority="1000">
            <action android:name="android.intent.action.BOOT_COMPLETED" />
            <action android:name="android.intent.action.QUICKBOOT_POWERON" />
            <category android:name="android.intent.category.DEFAULT" />
        </intent-filter>
    </receiver>

    <receiver
        android:name=".system.receiver.TodoAlarmReceiver"
        android:enabled="true"
        android:exported="false" />

    <receiver
        android:name=".system.receiver.TodoActionReceiver"
        android:enabled="true"
        android:exported="false" />
</application>
```

## 9. 测试策略

### 9.1 集成测试

```kotlin
@Test
fun testNotificationScheduling() {
    // 创建测试待办项
    val todoItem = TodoItem(
        title = "测试提醒",
        content = "测试内容",
        triggerTime = System.currentTimeMillis() + 60000 // 1分钟后
    )

    // 安排通知
    notificationManager.scheduleNotification(todoItem)

    // 验证闹钟已设置
    // 使用 ShadowAlarmManager 进行验证
}

@Test
fun testPermissionHandling() {
    // 测试权限检查和请求逻辑
    val hasPermission = permissionManager.checkNotificationPermission()

    if (!hasPermission) {
        permissionManager.requestNotificationPermission(activity)
    }

    // 验证权限请求结果
}
```

## 10. 总结

系统集成要点：

1. **通知系统**: 完整的通知创建、调度和管理
2. **权限管理**: 动态权限检查和请求处理
3. **后台任务**: 使用 WorkManager 处理后台操作
4. **系统事件**: 处理设备重启等系统事件
5. **生命周期**: 与应用生命周期正确集成
6. **错误处理**: 完善的异常处理和降级方案

这个系统集成方案确保了待办功能与 Android 系统的完美配合，提供了可靠的提醒服务。

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "\u5206\u6790\u73b0\u6709\u6587\u6863\u7ed3\u6784\u548c\u9879\u76ee\u9700\u6c42", "status": "completed", "activeForm": "\u5206\u6790\u73b0\u6709\u6587\u6863\u7ed3\u6784\u548c\u9879\u76ee\u9700\u6c42"}, {"content": "\u8bbe\u8ba1\u5f85\u529e\u529f\u80fd\u7684\u6574\u4f53\u67b6\u6784\u65b9\u6848", "status": "completed", "activeForm": "\u8bbe\u8ba1\u5f85\u529e\u529f\u80fd\u7684\u6574\u4f53\u67b6\u6784\u65b9\u6848"}, {"content": "\u7f16\u5199\u5f85\u529e\u529f\u80fd\u6570\u636e\u6a21\u578b\u8bbe\u8ba1\u6587\u6863", "status": "completed", "activeForm": "\u7f16\u5199\u5f85\u529e\u529f\u80fd\u6570\u636e\u6a21\u578b\u8bbe\u8ba1\u6587\u6863"}, {"content": "\u7f16\u5199\u5f85\u529e\u529f\u80fd\u4e1a\u52a1\u903b\u8f91\u8bbe\u8ba1\u6587\u6863", "status": "completed", "activeForm": "\u7f16\u5199\u5f85\u529e\u529f\u80fd\u4e1a\u52a1\u903b\u8f91\u8bbe\u8ba1\u6587\u6863"}, {"content": "\u7f16\u5199UI\u8bbe\u8ba1\u603b\u4f53\u65b9\u6848\u6587\u6863", "status": "completed", "activeForm": "\u7f16\u5199UI\u8bbe\u8ba1\u603b\u4f53\u65b9\u6848\u6587\u6863"}, {"content": "\u7f16\u5199\u5f85\u529e\u5217\u8868\u9875\u9762UI\u8bbe\u8ba1\u6587\u6863", "status": "completed", "activeForm": "\u7f16\u5199\u5f85\u529e\u5217\u8868\u9875\u9762UI\u8bbe\u8ba1\u6587\u6863"}, {"content": "\u7f16\u5199\u5f85\u529e\u8be6\u60c5\u548c\u7f16\u8f91UI\u8bbe\u8ba1\u6587\u6863", "status": "completed", "activeForm": "\u7f16\u5199\u5f85\u529e\u8be6\u60c5\u548c\u7f16\u8f91UI\u8bbe\u8ba1\u6587\u6863"}, {"content": "\u7f16\u5199UI\u7ec4\u4ef6\u5e93\u8bbe\u8ba1\u6587\u6863", "status": "completed", "activeForm": "\u7f16\u5199UI\u7ec4\u4ef6\u5e93\u8bbe\u8ba1\u6587\u6863"}, {"content": "\u7f16\u5199\u5f85\u529e\u529f\u80fd\u7cfb\u7edf\u96c6\u6210\u6587\u6863", "status": "completed", "activeForm": "\u7f16\u5199\u5f85\u529e\u529f\u80fd\u7cfb\u7edf\u96c6\u6210\u6587\u6863"}]