# 定时提醒小助手 - 系统集成开发技术方案

## 1. 概述

系统集成层是定时提醒小助手与 Android 系统深度集成的核心模块，负责处理定时任务调度、系统通知、广播接收和后台任务管理。本文档详细描述了系统集成的技术实现方案。

## 2. 系统集成架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────┐
│                    UI Layer                             │
├─────────────────────────────────────────────────────────┤
│                  Business Layer                         │
├─────────────────────────────────────────────────────────┤
│                   Data Layer                            │
├─────────────────────────────────────────────────────────┤
│                System Integration Layer                  │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐ │
│  │   Alarm     │ │Notification │ │   Broadcast         │ │
│  │  Manager    │ │   Manager   │ │   Receiver          │ │
│  └─────────────┘ └─────────────┘ └─────────────────────┘ │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐ │
│  │   Work      │ │ Permission  │ │   System            │ │
│  │  Manager    │ │   Manager   │ │   Services          │ │
│  └─────────────┘ └─────────────┘ └─────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 2.2 核心组件

#### 2.2.1 AlarmManager 集成
- **精确定时调度**: 使用 `setExactAndAllowWhileIdle()` 确保在低电耗模式下也能触发
- **重复任务管理**: 处理周期性提醒的调度逻辑
- **任务持久化**: 系统重启后自动恢复定时任务

#### 2.2.2 NotificationManager 集成
- **通知渠道管理**: 创建和管理不同优先级的通知渠道
- **富文本通知**: 支持大文本、图片、操作按钮等
- **通知交互**: 处理通知点击、操作按钮响应

#### 2.2.3 BroadcastReceiver 集成
- **系统事件监听**: 监听开机启动、时间变更等系统事件
- **定时任务触发**: 接收 AlarmManager 发出的定时事件
- **应用状态同步**: 处理应用更新、重装等状态变化

#### 2.2.4 WorkManager 集成
- **后台任务调度**: 处理不需要精确时间的后台任务
- **任务链管理**: 协调多个相关任务的执行顺序
- **约束条件**: 根据网络、电池等条件智能调度任务

## 3. 核心功能实现

### 3.1 定时任务调度系统

#### 3.1.1 AlarmScheduler 实现

```kotlin
interface AlarmScheduler {
    fun scheduleAlarm(plan: Plan)
    fun cancelAlarm(planId: String)
    fun rescheduleAlarm(plan: Plan)
    fun scheduleRepeatingAlarm(plan: Plan)
}

@Singleton
class AlarmSchedulerImpl @Inject constructor(
    @ApplicationContext private val context: Context
) : AlarmScheduler {

    private val alarmManager = context.getSystemService<AlarmManager>()

    override fun scheduleAlarm(plan: Plan) {
        val intent = Intent(context, AlarmReceiver::class.java).apply {
            putExtra(EXTRA_PLAN_ID, plan.id)
            putExtra(EXTRA_PLAN_TITLE, plan.title)
            putExtra(EXTRA_PLAN_CONTENT, plan.content)
        }

        val pendingIntent = PendingIntent.getBroadcast(
            context,
            plan.id.hashCode(),
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        val triggerTime = plan.triggerTime.toInstant(TimeZone.currentSystemDefault())
            .toEpochMilliseconds()

        when {
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
                if (alarmManager?.canScheduleExactAlarms() == true) {
                    alarmManager.setExactAndAllowWhileIdle(
                        AlarmManager.RTC_WAKEUP,
                        triggerTime,
                        pendingIntent
                    )
                } else {
                    // 请求精确闹钟权限
                    requestExactAlarmPermission()
                }
            }
            else -> {
                alarmManager?.setExactAndAllowWhileIdle(
                    AlarmManager.RTC_WAKEUP,
                    triggerTime,
                    pendingIntent
                )
            }
        }
    }
}
```

#### 3.1.2 重复任务处理

```kotlin
class RepeatingAlarmHandler @Inject constructor(
    private val alarmScheduler: AlarmScheduler,
    private val planRepository: PlanRepository
) {

    suspend fun handleRepeatingAlarm(plan: Plan) {
        if (plan.isRepeating) {
            val nextTriggerTime = calculateNextTriggerTime(plan)
            val updatedPlan = plan.copy(triggerTime = nextTriggerTime)

            // 更新数据库中的下次触发时间
            planRepository.updatePlan(updatedPlan)

            // 调度下次提醒
            alarmScheduler.scheduleAlarm(updatedPlan)
        }
    }

    private fun calculateNextTriggerTime(plan: Plan): LocalDateTime {
        return when (plan.repeatType) {
            RepeatType.DAILY -> plan.triggerTime.plusDays(1)
            RepeatType.WEEKLY -> plan.triggerTime.plusWeeks(1)
            RepeatType.MONTHLY -> plan.triggerTime.plusMonths(1)
            RepeatType.YEARLY -> plan.triggerTime.plusYears(1)
            RepeatType.CUSTOM -> calculateCustomRepeat(plan)
        }
    }
}
```

### 3.2 通知管理系统

#### 3.2.1 NotificationManager 实现

```kotlin
interface NotificationManager {
    fun showAlarmNotification(todoItem: TodoItem)
    fun showReminderNotification(plan: Plan)
    fun cancelNotification(notificationId: Int)
    fun updateNotificationProgress(notificationId: Int, progress: Int)
}

@Singleton
class NotificationManagerImpl @Inject constructor(
    @ApplicationContext private val context: Context
) : NotificationManager {

    private val notificationManager = context.getSystemService<android.app.NotificationManager>()

    override fun showAlarmNotification(todoItem: TodoItem) {
        val intent = Intent(context, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
            putExtra(EXTRA_TODO_ITEM_ID, todoItem.id)
            putExtra(EXTRA_SHOW_TODO_DIALOG, true)
        }

        val pendingIntent = PendingIntent.getActivity(
            context,
            todoItem.id.hashCode(),
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        val completeIntent = Intent(context, NotificationActionReceiver::class.java).apply {
            action = ACTION_COMPLETE_TODO
            putExtra(EXTRA_TODO_ITEM_ID, todoItem.id)
        }

        val completePendingIntent = PendingIntent.getBroadcast(
            context,
            todoItem.id.hashCode(),
            completeIntent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        val notification = NotificationCompat.Builder(context, ALARM_CHANNEL_ID)
            .setContentTitle(todoItem.title)
            .setContentText(todoItem.content)
            .setSmallIcon(R.drawable.ic_alarm)
            .setLargeIcon(getBitmapFromVector(R.drawable.ic_alarm_large))
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setCategory(NotificationCompat.CATEGORY_ALARM)
            .setAutoCancel(true)
            .setContentIntent(pendingIntent)
            .addAction(
                R.drawable.ic_check,
                context.getString(R.string.complete),
                completePendingIntent
            )
            .setStyle(
                NotificationCompat.BigTextStyle()
                    .bigText(todoItem.content)
            )
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
            .setDefaults(NotificationCompat.DEFAULT_ALL)
            .build()

        notificationManager?.notify(todoItem.id.hashCode(), notification)
    }
}
```

#### 3.2.2 通知渠道管理

```kotlin
@Singleton
class NotificationChannelManager @Inject constructor(
    @ApplicationContext private val context: Context
) {

    fun createNotificationChannels() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channels = listOf(
                createAlarmChannel(),
                createReminderChannel(),
                createSystemChannel()
            )

            val notificationManager = context.getSystemService<android.app.NotificationManager>()
            notificationManager?.createNotificationChannels(channels)
        }
    }

    @RequiresApi(Build.VERSION_CODES.O)
    private fun createAlarmChannel(): NotificationChannel {
        return NotificationChannel(
            ALARM_CHANNEL_ID,
            context.getString(R.string.alarm_channel_name),
            android.app.NotificationManager.IMPORTANCE_HIGH
        ).apply {
            description = context.getString(R.string.alarm_channel_description)
            enableVibration(true)
            vibrationPattern = longArrayOf(0, 1000, 500, 1000)
            setSound(
                RingtoneManager.getDefaultUri(RingtoneManager.TYPE_ALARM),
                AudioAttributes.Builder()
                    .setUsage(AudioAttributes.USAGE_ALARM)
                    .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)
                    .build()
            )
            setShowBadge(true)
            lockscreenVisibility = Notification.VISIBILITY_PUBLIC
        }
    }
}
```

### 3.3 广播接收器系统

#### 3.3.1 AlarmReceiver 实现

```kotlin
class AlarmReceiver : BroadcastReceiver() {

    override fun onReceive(context: Context, intent: Intent) {
        val planId = intent.getStringExtra(EXTRA_PLAN_ID) ?: return
        val planTitle = intent.getStringExtra(EXTRA_PLAN_TITLE) ?: return
        val planContent = intent.getStringExtra(EXTRA_PLAN_CONTENT) ?: return

        // 使用 goAsync() 处理异步操作
        val pendingResult = goAsync()

        CoroutineScope(Dispatchers.IO).launch {
            try {
                handleAlarmTrigger(context, planId, planTitle, planContent)
            } finally {
                pendingResult.finish()
            }
        }
    }

    private suspend fun handleAlarmTrigger(
        context: Context,
        planId: String,
        title: String,
        content: String
    ) {
        // 创建待办事项
        val todoItem = TodoItem(
            id = UUID.randomUUID().toString(),
            planId = planId,
            title = title,
            content = content,
            isCompleted = false,
            triggerTime = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault()),
            completedAt = null,
            createdAt = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())
        )

        // 保存到数据库
        val repository = EntryPoints.get(context, TodoRepositoryEntryPoint::class.java)
            .getTodoRepository()
        repository.insertTodoItem(todoItem)

        // 显示通知
        val notificationManager = EntryPoints.get(context, NotificationManagerEntryPoint::class.java)
            .getNotificationManager()
        notificationManager.showAlarmNotification(todoItem)

        // 处理重复提醒
        val planRepository = EntryPoints.get(context, PlanRepositoryEntryPoint::class.java)
            .getPlanRepository()
        val plan = planRepository.getPlanById(planId)
        if (plan?.isRepeating == true) {
            val repeatingHandler = EntryPoints.get(context, RepeatingAlarmHandlerEntryPoint::class.java)
                .getRepeatingAlarmHandler()
            repeatingHandler.handleRepeatingAlarm(plan)
        }
    }
}
```

#### 3.3.2 BootReceiver 实现

```kotlin
class BootReceiver : BroadcastReceiver() {

    override fun onReceive(context: Context, intent: Intent) {
        when (intent.action) {
            Intent.ACTION_BOOT_COMPLETED,
            Intent.ACTION_MY_PACKAGE_REPLACED,
            Intent.ACTION_PACKAGE_REPLACED -> {
                if (intent.action == Intent.ACTION_PACKAGE_REPLACED) {
                    val packageName = intent.dataString
                    if (packageName != "package:${context.packageName}") {
                        return
                    }
                }

                val pendingResult = goAsync()
                CoroutineScope(Dispatchers.IO).launch {
                    try {
                        restoreAlarms(context)
                    } finally {
                        pendingResult.finish()
                    }
                }
            }
        }
    }

    private suspend fun restoreAlarms(context: Context) {
        val repository = EntryPoints.get(context, PlanRepositoryEntryPoint::class.java)
            .getPlanRepository()
        val alarmScheduler = EntryPoints.get(context, AlarmSchedulerEntryPoint::class.java)
            .getAlarmScheduler()

        // 获取所有活跃的计划
        val activePlans = repository.getActivePlans()
        val currentTime = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())

        activePlans.forEach { plan ->
            // 只恢复未来的提醒
            if (plan.triggerTime > currentTime) {
                alarmScheduler.scheduleAlarm(plan)
            } else if (plan.isRepeating) {
                // 重复提醒需要计算下次触发时间
                val nextTriggerTime = calculateNextValidTriggerTime(plan, currentTime)
                val updatedPlan = plan.copy(triggerTime = nextTriggerTime)
                repository.updatePlan(updatedPlan)
                alarmScheduler.scheduleAlarm(updatedPlan)
            }
        }
    }
}
```

### 3.4 后台任务管理

#### 3.4.1 WorkManager 集成

```kotlin
class SyncWorker @AssistedInject constructor(
    @Assisted context: Context,
    @Assisted workerParams: WorkerParameters,
    private val todoRepository: TodoRepository,
    private val planRepository: PlanRepository
) : CoroutineWorker(context, workerParams) {

    override suspend fun doWork(): Result {
        return try {
            // 清理过期的已完成待办事项
            cleanupCompletedTodos()

            // 检查并更新过期的计划
            updateExpiredPlans()

            // 同步统计数据
            syncStatistics()

            Result.success()
        } catch (e: Exception) {
            if (runAttemptCount < 3) {
                Result.retry()
            } else {
                Result.failure()
            }
        }
    }

    private suspend fun cleanupCompletedTodos() {
        val cutoffTime = Clock.System.now()
            .minus(30, DateTimeUnit.DAY, TimeZone.currentSystemDefault())
            .toLocalDateTime(TimeZone.currentSystemDefault())

        todoRepository.deleteCompletedTodosBefore(cutoffTime)
    }

    @AssistedFactory
    interface Factory {
        fun create(context: Context, params: WorkerParameters): SyncWorker
    }
}
```

#### 3.4.2 WorkManager 调度

```kotlin
@Singleton
class WorkScheduler @Inject constructor(
    @ApplicationContext private val context: Context
) {

    private val workManager = WorkManager.getInstance(context)

    fun schedulePeriodicSync() {
        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .setRequiresBatteryNotLow(true)
            .build()

        val syncRequest = PeriodicWorkRequestBuilder<SyncWorker>(
            repeatInterval = 6,
            repeatIntervalTimeUnit = TimeUnit.HOURS
        )
            .setConstraints(constraints)
            .setBackoffCriteria(
                BackoffPolicy.EXPONENTIAL,
                WorkRequest.MIN_BACKOFF_MILLIS,
                TimeUnit.MILLISECONDS
            )
            .build()

        workManager.enqueueUniquePeriodicWork(
            "sync_work",
            ExistingPeriodicWorkPolicy.KEEP,
            syncRequest
        )
    }

    fun scheduleDataCleanup() {
        val cleanupRequest = OneTimeWorkRequestBuilder<DataCleanupWorker>()
            .setInitialDelay(1, TimeUnit.HOURS)
            .build()

        workManager.enqueueUniqueWork(
            "data_cleanup",
            ExistingWorkPolicy.REPLACE,
            cleanupRequest
        )
    }
}
```

## 4. 权限管理系统

### 4.1 权限检查和请求

```kotlin
@Singleton
class PermissionManager @Inject constructor(
    @ApplicationContext private val context: Context
) {

    fun checkNotificationPermission(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            ContextCompat.checkSelfPermission(
                context,
                Manifest.permission.POST_NOTIFICATIONS
            ) == PackageManager.PERMISSION_GRANTED
        } else {
            NotificationManagerCompat.from(context).areNotificationsEnabled()
        }
    }

    fun checkExactAlarmPermission(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            val alarmManager = context.getSystemService<AlarmManager>()
            alarmManager?.canScheduleExactAlarms() ?: false
        } else {
            true
        }
    }

    fun requestExactAlarmPermission(activity: Activity) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            val intent = Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM).apply {
                data = Uri.parse("package:${activity.packageName}")
            }
            activity.startActivity(intent)
        }
    }

    fun checkBatteryOptimization(): Boolean {
        val powerManager = context.getSystemService<PowerManager>()
        return powerManager?.isIgnoringBatteryOptimizations(context.packageName) ?: false
    }

    fun requestIgnoreBatteryOptimization(activity: Activity) {
        val intent = Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS).apply {
            data = Uri.parse("package:${activity.packageName}")
        }
        activity.startActivity(intent)
    }
}
```

### 4.2 权限状态监听

```kotlin
class PermissionStateMonitor @Inject constructor(
    private val permissionManager: PermissionManager,
    @ApplicationScope private val scope: CoroutineScope
) {

    private val _permissionState = MutableStateFlow(PermissionState())
    val permissionState = _permissionState.asStateFlow()

    fun startMonitoring() {
        scope.launch {
            while (true) {
                val currentState = PermissionState(
                    hasNotificationPermission = permissionManager.checkNotificationPermission(),
                    hasExactAlarmPermission = permissionManager.checkExactAlarmPermission(),
                    isBatteryOptimizationIgnored = permissionManager.checkBatteryOptimization()
                )

                _permissionState.value = currentState
                delay(5000) // 每5秒检查一次
            }
        }
    }
}

data class PermissionState(
    val hasNotificationPermission: Boolean = false,
    val hasExactAlarmPermission: Boolean = false,
    val isBatteryOptimizationIgnored: Boolean = false
) {
    val allPermissionsGranted: Boolean
        get() = hasNotificationPermission && hasExactAlarmPermission && isBatteryOptimizationIgnored
}
```

## 5. 错误处理和容错机制

### 5.1 系统级错误处理

```kotlin
@Singleton
class SystemErrorHandler @Inject constructor(
    @ApplicationContext private val context: Context,
    private val logger: Logger
) {

    fun handleAlarmScheduleError(plan: Plan, error: Throwable) {
        logger.error("Failed to schedule alarm for plan ${plan.id}", error)

        when (error) {
            is SecurityException -> {
                // 权限不足，记录错误并通知用户
                notifyPermissionError()
            }
            is IllegalStateException -> {
                // 系统状态异常，尝试延迟重试
                scheduleRetry(plan)
            }
            else -> {
                // 其他错误，记录并使用 WorkManager 作为后备
                scheduleWithWorkManager(plan)
            }
        }
    }

    private fun scheduleRetry(plan: Plan) {
        val retryRequest = OneTimeWorkRequestBuilder<AlarmRetryWorker>()
            .setInputData(
                Data.Builder()
                    .putString("plan_id", plan.id)
                    .build()
            )
            .setInitialDelay(5, TimeUnit.MINUTES)
            .build()

        WorkManager.getInstance(context).enqueue(retryRequest)
    }
}
```

### 5.2 网络和存储错误处理

```kotlin
class StorageErrorHandler @Inject constructor(
    private val logger: Logger
) {

    suspend fun <T> safeExecute(
        operation: suspend () -> T,
        fallback: suspend () -> T? = { null },
        retryCount: Int = 3
    ): T? {
        repeat(retryCount) { attempt ->
            try {
                return operation()
            } catch (e: Exception) {
                logger.warn("Operation failed, attempt ${attempt + 1}/$retryCount", e)

                if (attempt == retryCount - 1) {
                    logger.error("Operation failed after $retryCount attempts", e)
                    return fallback()
                }

                delay(1000L * (attempt + 1)) // 指数退避
            }
        }
        return null
    }
}
```

## 6. 性能优化策略

### 6.1 内存优化

```kotlin
class SystemResourceManager @Inject constructor(
    @ApplicationContext private val context: Context
) {

    fun optimizeMemoryUsage() {
        // 清理不必要的缓存
        clearImageCache()

        // 释放不活跃的资源
        releaseInactiveResources()

        // 触发垃圾回收（谨慎使用）
        if (isMemoryPressureHigh()) {
            System.gc()
        }
    }

    private fun isMemoryPressureHigh(): Boolean {
        val activityManager = context.getSystemService<ActivityManager>()
        val memoryInfo = ActivityManager.MemoryInfo()
        activityManager?.getMemoryInfo(memoryInfo)

        return memoryInfo.lowMemory ||
               (memoryInfo.availMem < memoryInfo.threshold * 1.5)
    }
}
```

### 6.2 电池优化

```kotlin
class PowerOptimizer @Inject constructor(
    @ApplicationContext private val context: Context,
    private val alarmScheduler: AlarmScheduler
) {

    fun optimizeForBatteryLife() {
        // 合并临近的闹钟
        consolidateNearbyAlarms()

        // 使用 WorkManager 处理非关键任务
        deferNonCriticalTasks()

        // 调整同步频率
        adjustSyncFrequency()
    }

    private suspend fun consolidateNearbyAlarms() {
        // 获取未来1小时内的所有闹钟
        val upcomingAlarms = getUpcomingAlarms(Duration.ofHours(1))

        // 按时间分组，间隔小于5分钟的归为一组
        val groupedAlarms = groupAlarmsByTime(upcomingAlarms, Duration.ofMinutes(5))

        // 为每组选择一个代表性时间，重新调度
        groupedAlarms.forEach { group ->
            if (group.size > 1) {
                val representativeTime = group.minBy { it.triggerTime }.triggerTime
                group.forEach { alarm ->
                    alarmScheduler.rescheduleAlarm(alarm.copy(triggerTime = representativeTime))
                }
            }
        }
    }
}
```

## 7. 测试策略

### 7.1 单元测试

```kotlin
@RunWith(MockitoJUnitRunner::class)
class AlarmSchedulerTest {

    @Mock
    private lateinit var context: Context

    @Mock
    private lateinit var alarmManager: AlarmManager

    private lateinit var alarmScheduler: AlarmSchedulerImpl

    @Before
    fun setup() {
        whenever(context.getSystemService<AlarmManager>()).thenReturn(alarmManager)
        alarmScheduler = AlarmSchedulerImpl(context)
    }

    @Test
    fun `scheduleAlarm should set exact alarm when permission granted`() {
        // Given
        val plan = createTestPlan()
        whenever(alarmManager.canScheduleExactAlarms()).thenReturn(true)

        // When
        alarmScheduler.scheduleAlarm(plan)

        // Then
        verify(alarmManager).setExactAndAllowWhileIdle(
            eq(AlarmManager.RTC_WAKEUP),
            any(),
            any()
        )
    }
}
```

### 7.2 集成测试

```kotlin
@RunWith(AndroidJUnit4::class)
@LargeTest
class SystemIntegrationTest {

    @get:Rule
    val hiltRule = HiltAndroidRule(this)

    @Inject
    lateinit var alarmScheduler: AlarmScheduler

    @Inject
    lateinit var notificationManager: NotificationManager

    @Before
    fun setup() {
        hiltRule.inject()
    }

    @Test
    fun testAlarmToNotificationFlow() {
        // 测试从闹钟调度到通知显示的完整流程
        val plan = createTestPlan()

        // 调度闹钟
        alarmScheduler.scheduleAlarm(plan)

        // 模拟闹钟触发
        val intent = Intent().apply {
            putExtra(EXTRA_PLAN_ID, plan.id)
            putExtra(EXTRA_PLAN_TITLE, plan.title)
            putExtra(EXTRA_PLAN_CONTENT, plan.content)
        }

        val receiver = AlarmReceiver()
        receiver.onReceive(InstrumentationRegistry.getInstrumentation().context, intent)

        // 验证通知是否显示
        // 这里需要使用 UiAutomator 或其他工具验证系统通知
    }
}
```

## 8. 监控和日志

### 8.1 系统事件监控

```kotlin
@Singleton
class SystemEventMonitor @Inject constructor(
    private val logger: Logger,
    @ApplicationScope private val scope: CoroutineScope
) {

    private val _systemEvents = MutableSharedFlow<SystemEvent>()
    val systemEvents = _systemEvents.asSharedFlow()

    fun logAlarmScheduled(planId: String, triggerTime: LocalDateTime) {
        val event = SystemEvent.AlarmScheduled(planId, triggerTime)
        logger.info("Alarm scheduled: $event")
        scope.launch { _systemEvents.emit(event) }
    }

    fun logAlarmTriggered(planId: String, actualTime: LocalDateTime) {
        val event = SystemEvent.AlarmTriggered(planId, actualTime)
        logger.info("Alarm triggered: $event")
        scope.launch { _systemEvents.emit(event) }
    }

    fun logNotificationShown(todoId: String) {
        val event = SystemEvent.NotificationShown(todoId)
        logger.info("Notification shown: $event")
        scope.launch { _systemEvents.emit(event) }
    }
}

sealed class SystemEvent {
    data class AlarmScheduled(val planId: String, val triggerTime: LocalDateTime) : SystemEvent()
    data class AlarmTriggered(val planId: String, val actualTime: LocalDateTime) : SystemEvent()
    data class NotificationShown(val todoId: String) : SystemEvent()
    data class PermissionChanged(val permission: String, val granted: Boolean) : SystemEvent()
}
```

### 8.2 性能监控

```kotlin
@Singleton
class PerformanceMonitor @Inject constructor(
    private val logger: Logger
) {

    inline fun <T> measureTime(operation: String, block: () -> T): T {
        val startTime = System.nanoTime()
        return try {
            block()
        } finally {
            val duration = (System.nanoTime() - startTime) / 1_000_000
            logger.debug("$operation took ${duration}ms")

            if (duration > 1000) { // 超过1秒的操作需要警告
                logger.warn("Slow operation detected: $operation took ${duration}ms")
            }
        }
    }

    fun reportMemoryUsage() {
        val runtime = Runtime.getRuntime()
        val usedMemory = runtime.totalMemory() - runtime.freeMemory()
        val maxMemory = runtime.maxMemory()
        val memoryUsagePercent = (usedMemory * 100) / maxMemory

        logger.info("Memory usage: ${usedMemory / 1024 / 1024}MB / ${maxMemory / 1024 / 1024}MB ($memoryUsagePercent%)")

        if (memoryUsagePercent > 80) {
            logger.warn("High memory usage detected: $memoryUsagePercent%")
        }
    }
}
```

## 9. 安全考虑

### 9.1 数据安全

```kotlin
@Singleton
class SecurityManager @Inject constructor(
    @ApplicationContext private val context: Context
) {

    fun validatePlanData(plan: Plan): Boolean {
        // 验证计划数据的完整性和安全性
        return plan.title.isNotBlank() &&
               plan.content.length <= MAX_CONTENT_LENGTH &&
               plan.triggerTime > Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault()) &&
               !containsMaliciousContent(plan.content)
    }

    private fun containsMaliciousContent(content: String): Boolean {
        // 检查恶意内容，如脚本注入等
        val maliciousPatterns = listOf(
            "<script",
            "javascript:",
            "data:text/html",
            "vbscript:"
        )

        return maliciousPatterns.any { pattern ->
            content.contains(pattern, ignoreCase = true)
        }
    }

    fun sanitizeUserInput(input: String): String {
        return input
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("'", "&#x27;")
            .replace("/", "&#x2F;")
            .trim()
            .take(MAX_INPUT_LENGTH)
    }
}
```

### 9.2 权限安全

```kotlin
class PermissionSecurityChecker @Inject constructor(
    @ApplicationContext private val context: Context,
    private val logger: Logger
) {

    fun checkPermissionSecurity() {
        // 检查应用是否被授予了不必要的权限
        val grantedPermissions = getGrantedPermissions()
        val requiredPermissions = getRequiredPermissions()

        val unnecessaryPermissions = grantedPermissions - requiredPermissions
        if (unnecessaryPermissions.isNotEmpty()) {
            logger.warn("Unnecessary permissions detected: $unnecessaryPermissions")
        }

        // 检查敏感权限的使用情况
        checkSensitivePermissionUsage()
    }

    private fun getGrantedPermissions(): Set<String> {
        val packageInfo = context.packageManager.getPackageInfo(
            context.packageName,
            PackageManager.GET_PERMISSIONS
        )

        return packageInfo.requestedPermissions?.filter { permission ->
            ContextCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_GRANTED
        }?.toSet() ?: emptySet()
    }
}
```

## 10. 部署和维护

### 10.1 版本升级处理

```kotlin
class SystemUpgradeHandler @Inject constructor(
    private val dataStore: DataStore<Preferences>,
    private val alarmScheduler: AlarmScheduler,
    private val planRepository: PlanRepository
) {

    suspend fun handleUpgrade(oldVersion: Int, newVersion: Int) {
        when {
            oldVersion < 2 && newVersion >= 2 -> {
                // 升级到版本2的处理逻辑
                migrateAlarmData()
            }
            oldVersion < 3 && newVersion >= 3 -> {
                // 升级到版本3的处理逻辑
                updateNotificationChannels()
            }
        }

        // 重新调度所有活跃的闹钟
        rescheduleAllActiveAlarms()
    }

    private suspend fun rescheduleAllActiveAlarms() {
        val activePlans = planRepository.getActivePlans()
        activePlans.forEach { plan ->
            alarmScheduler.scheduleAlarm(plan)
        }
    }
}
```

### 10.2 系统健康检查

```kotlin
@Singleton
class SystemHealthChecker @Inject constructor(
    private val permissionManager: PermissionManager,
    private val alarmScheduler: AlarmScheduler,
    private val logger: Logger
) {

    suspend fun performHealthCheck(): HealthCheckResult {
        val results = mutableMapOf<String, Boolean>()

        // 检查权限状态
        results["notification_permission"] = permissionManager.checkNotificationPermission()
        results["exact_alarm_permission"] = permissionManager.checkExactAlarmPermission()
        results["battery_optimization"] = permissionManager.checkBatteryOptimization()

        // 检查系统服务可用性
        results["alarm_manager_available"] = checkAlarmManagerAvailability()
        results["notification_manager_available"] = checkNotificationManagerAvailability()

        // 检查数据库连接
        results["database_accessible"] = checkDatabaseAccessibility()

        val overallHealth = results.values.all { it }

        return HealthCheckResult(
            isHealthy = overallHealth,
            checks = results,
            timestamp = Clock.System.now()
        )
    }

    private fun checkAlarmManagerAvailability(): Boolean {
        return try {
            val alarmManager = context.getSystemService<AlarmManager>()
            alarmManager != null
        } catch (e: Exception) {
            logger.error("AlarmManager not available", e)
            false
        }
    }
}

data class HealthCheckResult(
    val isHealthy: Boolean,
    val checks: Map<String, Boolean>,
    val timestamp: Instant
)
```

## 11. 总结

系统集成层是定时提醒小助手的核心基础设施，负责与 Android 系统的深度集成。通过合理的架构设计和实现，确保应用能够：

1. **可靠的定时触发**: 通过 AlarmManager 和 BroadcastReceiver 实现精确的定时提醒
2. **优秀的用户体验**: 通过 NotificationManager 提供丰富的通知交互
3. **强大的容错能力**: 通过多层错误处理和重试机制确保系统稳定性
4. **高效的资源利用**: 通过 WorkManager 和性能优化策略减少资源消耗
5. **安全的数据处理**: 通过权限管理和数据验证确保应用安全

这个系统集成方案为整个应用提供了坚实的技术基础，确保定时提醒功能的可靠性和用户体验的优秀性。