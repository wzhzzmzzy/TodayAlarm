# 定时提醒小助手 - 数据层开发指南

## 1. 开发概述

数据层负责管理应用的数据存储和访问，包括：
- Room 数据库设计和实现
- 数据实体定义
- DAO (数据访问对象) 实现
- Repository 模式实现
- DataStore 配置存储

## 2. 步骤一：创建数据实体 (Entities)

### 2.1 创建 Plan 实体
```kotlin
// data/database/entities/Plan.kt
@Entity(tableName = "plans")
data class Plan(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    val title: String,
    val content: String,
    val triggerTime: Long, // 使用时间戳存储
    val isRepeating: Boolean = false,
    val repeatType: String = RepeatType.NONE.name,
    val repeatInterval: Int = 1, // 重复间隔
    val isActive: Boolean = true,
    val createdAt: Long = System.currentTimeMillis(),
    val updatedAt: Long = System.currentTimeMillis()
)
```

### 2.2 创建 TodoItem 实体
```kotlin
// data/database/entities/TodoItem.kt
@Entity(
    tableName = "todo_items",
    foreignKeys = [
        ForeignKey(
            entity = Plan::class,
            parentColumns = ["id"],
            childColumns = ["planId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index(value = ["planId"])]
)
data class TodoItem(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    val planId: String,
    val title: String,
    val content: String,
    val isCompleted: Boolean = false,
    val triggerTime: Long,
    val completedAt: Long? = null,
    val createdAt: Long = System.currentTimeMillis()
)
```

### 2.3 创建枚举类
```kotlin
// data/database/entities/RepeatType.kt
enum class RepeatType {
    NONE,       // 不重复
    DAILY,      // 每日
    WEEKLY,     // 每周
    MONTHLY,    // 每月
    YEARLY,     // 每年
    CUSTOM      // 自定义
}
```

**依赖**: 无额外依赖，使用 Room 注解

## 3. 步骤二：创建 DAO (数据访问对象)

### 3.1 创建 PlanDao
```kotlin
// data/database/dao/PlanDao.kt
@Dao
interface PlanDao {

    @Query("SELECT * FROM plans ORDER BY triggerTime ASC")
    fun getAllPlans(): Flow<List<Plan>>

    @Query("SELECT * FROM plans WHERE isActive = 1 ORDER BY triggerTime ASC")
    fun getActivePlans(): Flow<List<Plan>>

    @Query("SELECT * FROM plans WHERE id = :id")
    suspend fun getPlanById(id: String): Plan?

    @Query("SELECT * FROM plans WHERE triggerTime BETWEEN :startTime AND :endTime")
    fun getPlansInTimeRange(startTime: Long, endTime: Long): Flow<List<Plan>>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertPlan(plan: Plan)

    @Update
    suspend fun updatePlan(plan: Plan)

    @Delete
    suspend fun deletePlan(plan: Plan)

    @Query("DELETE FROM plans WHERE id = :id")
    suspend fun deletePlanById(id: String)

    @Query("UPDATE plans SET isActive = :isActive WHERE id = :id")
    suspend fun updatePlanActiveStatus(id: String, isActive: Boolean)

    @Query("UPDATE plans SET updatedAt = :updatedAt WHERE id = :id")
    suspend fun updatePlanTimestamp(id: String, updatedAt: Long = System.currentTimeMillis())
}
```

### 3.2 创建 TodoItemDao
```kotlin
// data/database/dao/TodoItemDao.kt
@Dao
interface TodoItemDao {

    @Query("SELECT * FROM todo_items ORDER BY triggerTime DESC")
    fun getAllTodoItems(): Flow<List<TodoItem>>

    @Query("SELECT * FROM todo_items WHERE isCompleted = 0 ORDER BY triggerTime ASC")
    fun getPendingTodoItems(): Flow<List<TodoItem>>

    @Query("SELECT * FROM todo_items WHERE isCompleted = 1 ORDER BY completedAt DESC")
    fun getCompletedTodoItems(): Flow<List<TodoItem>>

    @Query("SELECT * FROM todo_items WHERE planId = :planId ORDER BY triggerTime DESC")
    fun getTodoItemsByPlanId(planId: String): Flow<List<TodoItem>>

    @Query("SELECT * FROM todo_items WHERE id = :id")
    suspend fun getTodoItemById(id: String): TodoItem?

    @Query("SELECT * FROM todo_items WHERE triggerTime BETWEEN :startTime AND :endTime")
    fun getTodoItemsInTimeRange(startTime: Long, endTime: Long): Flow<List<TodoItem>>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertTodoItem(todoItem: TodoItem)

    @Update
    suspend fun updateTodoItem(todoItem: TodoItem)

    @Delete
    suspend fun deleteTodoItem(todoItem: TodoItem)

    @Query("UPDATE todo_items SET isCompleted = :isCompleted, completedAt = :completedAt WHERE id = :id")
    suspend fun updateTodoItemCompletionStatus(
        id: String,
        isCompleted: Boolean,
        completedAt: Long? = if (isCompleted) System.currentTimeMillis() else null
    )

    @Query("DELETE FROM todo_items WHERE planId = :planId")
    suspend fun deleteTodoItemsByPlanId(planId: String)
}
```

**依赖**: Room KTX, Coroutines Flow

## 4. 步骤三：创建数据库配置

### 4.1 创建类型转换器
```kotlin
// data/database/Converters.kt
class Converters {

    @TypeConverter
    fun fromRepeatType(repeatType: RepeatType): String {
        return repeatType.name
    }

    @TypeConverter
    fun toRepeatType(repeatType: String): RepeatType {
        return try {
            RepeatType.valueOf(repeatType)
        } catch (e: IllegalArgumentException) {
            RepeatType.NONE
        }
    }
}
```

### 4.2 创建数据库类
```kotlin
// data/database/AppDatabase.kt
@Database(
    entities = [Plan::class, TodoItem::class],
    version = 1,
    exportSchema = false
)
@TypeConverters(Converters::class)
abstract class AppDatabase : RoomDatabase() {

    abstract fun planDao(): PlanDao
    abstract fun todoItemDao(): TodoItemDao

    companion object {
        const val DATABASE_NAME = "today_alarm_database"
    }
}
```

### 4.3 创建数据库模块
```kotlin
// data/database/DatabaseModule.kt
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {

    @Provides
    @Singleton
    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            AppDatabase.DATABASE_NAME
        )
            .fallbackToDestructiveMigration() // 开发阶段使用，生产环境需要提供迁移策略
            .build()
    }

    @Provides
    fun providePlanDao(database: AppDatabase): PlanDao {
        return database.planDao()
    }

    @Provides
    fun provideTodoItemDao(database: AppDatabase): TodoItemDao {
        return database.todoItemDao()
    }
}
```

**依赖**: Room, Hilt

## 5. 步骤四：创建 DataStore 配置

### 5.1 创建配置数据类
```kotlin
// data/datastore/UserPreferences.kt
@Serializable
data class UserPreferences(
    val isFirstLaunch: Boolean = true,
    val notificationEnabled: Boolean = true,
    val vibrationEnabled: Boolean = true,
    val soundEnabled: Boolean = true,
    val defaultReminderMinutes: Int = 15,
    val themeMode: String = "SYSTEM", // LIGHT, DARK, SYSTEM
    val weekStartDay: Int = 1, // 1=Monday, 7=Sunday
    val timeFormat24Hour: Boolean = true
)
```

### 5.2 创建 DataStore
```kotlin
// data/datastore/UserPreferencesDataStore.kt
@Singleton
class UserPreferencesDataStore @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val dataStore = context.dataStore

    val userPreferences: Flow<UserPreferences> = dataStore.data
        .catch { exception ->
            if (exception is IOException) {
                emit(emptyPreferences())
            } else {
                throw exception
            }
        }
        .map { preferences ->
            UserPreferences(
                isFirstLaunch = preferences[PreferencesKeys.IS_FIRST_LAUNCH] ?: true,
                notificationEnabled = preferences[PreferencesKeys.NOTIFICATION_ENABLED] ?: true,
                vibrationEnabled = preferences[PreferencesKeys.VIBRATION_ENABLED] ?: true,
                soundEnabled = preferences[PreferencesKeys.SOUND_ENABLED] ?: true,
                defaultReminderMinutes = preferences[PreferencesKeys.DEFAULT_REMINDER_MINUTES] ?: 15,
                themeMode = preferences[PreferencesKeys.THEME_MODE] ?: "SYSTEM",
                weekStartDay = preferences[PreferencesKeys.WEEK_START_DAY] ?: 1,
                timeFormat24Hour = preferences[PreferencesKeys.TIME_FORMAT_24_HOUR] ?: true
            )
        }

    suspend fun updateFirstLaunch(isFirstLaunch: Boolean) {
        dataStore.edit { preferences ->
            preferences[PreferencesKeys.IS_FIRST_LAUNCH] = isFirstLaunch
        }
    }

    suspend fun updateNotificationEnabled(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PreferencesKeys.NOTIFICATION_ENABLED] = enabled
        }
    }

    suspend fun updateVibrationEnabled(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PreferencesKeys.VIBRATION_ENABLED] = enabled
        }
    }

    suspend fun updateSoundEnabled(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PreferencesKeys.SOUND_ENABLED] = enabled
        }
    }

    suspend fun updateDefaultReminderMinutes(minutes: Int) {
        dataStore.edit { preferences ->
            preferences[PreferencesKeys.DEFAULT_REMINDER_MINUTES] = minutes
        }
    }

    suspend fun updateThemeMode(themeMode: String) {
        dataStore.edit { preferences ->
            preferences[PreferencesKeys.THEME_MODE] = themeMode
        }
    }

    suspend fun updateWeekStartDay(day: Int) {
        dataStore.edit { preferences ->
            preferences[PreferencesKeys.WEEK_START_DAY] = day
        }
    }

    suspend fun updateTimeFormat24Hour(is24Hour: Boolean) {
        dataStore.edit { preferences ->
            preferences[PreferencesKeys.TIME_FORMAT_24_HOUR] = is24Hour
        }
    }

    private object PreferencesKeys {
        val IS_FIRST_LAUNCH = booleanPreferencesKey("is_first_launch")
        val NOTIFICATION_ENABLED = booleanPreferencesKey("notification_enabled")
        val VIBRATION_ENABLED = booleanPreferencesKey("vibration_enabled")
        val SOUND_ENABLED = booleanPreferencesKey("sound_enabled")
        val DEFAULT_REMINDER_MINUTES = intPreferencesKey("default_reminder_minutes")
        val THEME_MODE = stringPreferencesKey("theme_mode")
        val WEEK_START_DAY = intPreferencesKey("week_start_day")
        val TIME_FORMAT_24_HOUR = booleanPreferencesKey("time_format_24_hour")
    }
}

private val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "user_preferences")
```

**依赖**: DataStore Preferences, Kotlinx Serialization

## 6. 步骤五：实现 Repository

### 6.1 创建 Repository 接口
```kotlin
// domain/repository/PlanRepository.kt
interface PlanRepository {
    fun getAllPlans(): Flow<List<Plan>>
    fun getActivePlans(): Flow<List<Plan>>
    suspend fun getPlanById(id: String): Plan?
    fun getPlansInTimeRange(startTime: Long, endTime: Long): Flow<List<Plan>>
    suspend fun insertPlan(plan: Plan)
    suspend fun updatePlan(plan: Plan)
    suspend fun deletePlan(plan: Plan)
    suspend fun deletePlanById(id: String)
    suspend fun updatePlanActiveStatus(id: String, isActive: Boolean)
}

// domain/repository/TodoItemRepository.kt
interface TodoItemRepository {
    fun getAllTodoItems(): Flow<List<TodoItem>>
    fun getPendingTodoItems(): Flow<List<TodoItem>>
    fun getCompletedTodoItems(): Flow<List<TodoItem>>
    fun getTodoItemsByPlanId(planId: String): Flow<List<TodoItem>>
    suspend fun getTodoItemById(id: String): TodoItem?
    fun getTodoItemsInTimeRange(startTime: Long, endTime: Long): Flow<List<TodoItem>>
    suspend fun insertTodoItem(todoItem: TodoItem)
    suspend fun updateTodoItem(todoItem: TodoItem)
    suspend fun deleteTodoItem(todoItem: TodoItem)
    suspend fun updateTodoItemCompletionStatus(id: String, isCompleted: Boolean)
    suspend fun deleteTodoItemsByPlanId(planId: String)
}
```

### 6.2 实现 Repository
```kotlin
// data/repository/PlanRepositoryImpl.kt
@Singleton
class PlanRepositoryImpl @Inject constructor(
    private val planDao: PlanDao
) : PlanRepository {

    override fun getAllPlans(): Flow<List<Plan>> = planDao.getAllPlans()

    override fun getActivePlans(): Flow<List<Plan>> = planDao.getActivePlans()

    override suspend fun getPlanById(id: String): Plan? = planDao.getPlanById(id)

    override fun getPlansInTimeRange(startTime: Long, endTime: Long): Flow<List<Plan>> =
        planDao.getPlansInTimeRange(startTime, endTime)

    override suspend fun insertPlan(plan: Plan) = planDao.insertPlan(plan)

    override suspend fun updatePlan(plan: Plan) = planDao.updatePlan(plan.copy(updatedAt = System.currentTimeMillis()))

    override suspend fun deletePlan(plan: Plan) = planDao.deletePlan(plan)

    override suspend fun deletePlanById(id: String) = planDao.deletePlanById(id)

    override suspend fun updatePlanActiveStatus(id: String, isActive: Boolean) {
        planDao.updatePlanActiveStatus(id, isActive)
        planDao.updatePlanTimestamp(id)
    }
}

// data/repository/TodoItemRepositoryImpl.kt
@Singleton
class TodoItemRepositoryImpl @Inject constructor(
    private val todoItemDao: TodoItemDao
) : TodoItemRepository {

    override fun getAllTodoItems(): Flow<List<TodoItem>> = todoItemDao.getAllTodoItems()

    override fun getPendingTodoItems(): Flow<List<TodoItem>> = todoItemDao.getPendingTodoItems()

    override fun getCompletedTodoItems(): Flow<List<TodoItem>> = todoItemDao.getCompletedTodoItems()

    override fun getTodoItemsByPlanId(planId: String): Flow<List<TodoItem>> =
        todoItemDao.getTodoItemsByPlanId(planId)

    override suspend fun getTodoItemById(id: String): TodoItem? = todoItemDao.getTodoItemById(id)

    override fun getTodoItemsInTimeRange(startTime: Long, endTime: Long): Flow<List<TodoItem>> =
        todoItemDao.getTodoItemsInTimeRange(startTime, endTime)

    override suspend fun insertTodoItem(todoItem: TodoItem) = todoItemDao.insertTodoItem(todoItem)

    override suspend fun updateTodoItem(todoItem: TodoItem) = todoItemDao.updateTodoItem(todoItem)

    override suspend fun deleteTodoItem(todoItem: TodoItem) = todoItemDao.deleteTodoItem(todoItem)

    override suspend fun updateTodoItemCompletionStatus(id: String, isCompleted: Boolean) =
        todoItemDao.updateTodoItemCompletionStatus(id, isCompleted)

    override suspend fun deleteTodoItemsByPlanId(planId: String) =
        todoItemDao.deleteTodoItemsByPlanId(planId)
}
```

### 6.3 创建 Repository 模块
```kotlin
// data/repository/RepositoryModule.kt
@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {

    @Binds
    abstract fun bindPlanRepository(
        planRepositoryImpl: PlanRepositoryImpl
    ): PlanRepository

    @Binds
    abstract fun bindTodoItemRepository(
        todoItemRepositoryImpl: TodoItemRepositoryImpl
    ): TodoItemRepository
}
```

**依赖**: Hilt, Coroutines

## 7. 步骤六：创建工具类

### 7.1 时间工具类
```kotlin
// utils/TimeUtils.kt
object TimeUtils {

    fun formatTime(timestamp: Long, is24Hour: Boolean = true): String {
        val format = if (is24Hour) "HH:mm" else "hh:mm a"
        return SimpleDateFormat(format, Locale.getDefault()).format(Date(timestamp))
    }

    fun formatDate(timestamp: Long): String {
        return SimpleDateFormat("yyyy-MM-dd", Locale.getDefault()).format(Date(timestamp))
    }

    fun formatDateTime(timestamp: Long, is24Hour: Boolean = true): String {
        val timeFormat = if (is24Hour) "HH:mm" else "hh:mm a"
        val format = "yyyy-MM-dd $timeFormat"
        return SimpleDateFormat(format, Locale.getDefault()).format(Date(timestamp))
    }

    fun getStartOfDay(timestamp: Long): Long {
        val calendar = Calendar.getInstance()
        calendar.timeInMillis = timestamp
        calendar.set(Calendar.HOUR_OF_DAY, 0)
        calendar.set(Calendar.MINUTE, 0)
        calendar.set(Calendar.SECOND, 0)
        calendar.set(Calendar.MILLISECOND, 0)
        return calendar.timeInMillis
    }

    fun getEndOfDay(timestamp: Long): Long {
        val calendar = Calendar.getInstance()
        calendar.timeInMillis = timestamp
        calendar.set(Calendar.HOUR_OF_DAY, 23)
        calendar.set(Calendar.MINUTE, 59)
        calendar.set(Calendar.SECOND, 59)
        calendar.set(Calendar.MILLISECOND, 999)
        return calendar.timeInMillis
    }

    fun getStartOfWeek(timestamp: Long, weekStartDay: Int = Calendar.MONDAY): Long {
        val calendar = Calendar.getInstance()
        calendar.timeInMillis = timestamp
        calendar.firstDayOfWeek = weekStartDay
        calendar.set(Calendar.DAY_OF_WEEK, weekStartDay)
        return getStartOfDay(calendar.timeInMillis)
    }

    fun getEndOfWeek(timestamp: Long, weekStartDay: Int = Calendar.MONDAY): Long {
        val startOfWeek = getStartOfWeek(timestamp, weekStartDay)
        val calendar = Calendar.getInstance()
        calendar.timeInMillis = startOfWeek
        calendar.add(Calendar.DAY_OF_WEEK, 6)
        return getEndOfDay(calendar.timeInMillis)
    }
}
```

**依赖**: 无额外依赖

## 8. 测试代码

### 8.1 创建测试数据
```kotlin
// data/database/TestData.kt
object TestData {

    fun createSamplePlans(): List<Plan> {
        val now = System.currentTimeMillis()
        return listOf(
            Plan(
                title = "晨练提醒",
                content = "记得去公园跑步",
                triggerTime = now + 3600000, // 1小时后
                isRepeating = true,
                repeatType = RepeatType.DAILY.name
            ),
            Plan(
                title = "会议提醒",
                content = "下午2点项目会议",
                triggerTime = now + 7200000, // 2小时后
                isRepeating = false
            ),
            Plan(
                title = "买菜提醒",
                content = "下班路上买菜",
                triggerTime = now + 28800000, // 8小时后
                isRepeating = true,
                repeatType = RepeatType.WEEKLY.name
            )
        )
    }

    fun createSampleTodoItems(planIds: List<String>): List<TodoItem> {
        val now = System.currentTimeMillis()
        return listOf(
            TodoItem(
                planId = planIds[0],
                title = "晨练提醒",
                content = "记得去公园跑步",
                triggerTime = now - 3600000, // 1小时前
                isCompleted = true,
                completedAt = now - 1800000 // 30分钟前完成
            ),
            TodoItem(
                planId = planIds[1],
                title = "会议提醒",
                content = "下午2点项目会议",
                triggerTime = now + 3600000 // 1小时后
            )
        )
    }
}
```

## 9. 验证步骤

### 9.1 编译验证
```bash
./gradlew assembleDebug
```

### 9.2 数据库验证
可以使用 Android Studio 的 Database Inspector 查看数据库结构

### 9.3 单元测试
```kotlin
// 在后续的测试章节中详细说明
```

## 10. 下一步

数据层开发完成后，可以继续：
1. 业务层开发（参考 `04-业务层开发.md`）
2. UI层开发（参考 `05-UI层开发.md`）

## 11. 常见问题

### 11.1 数据库迁移
- 生产环境需要提供迁移策略
- 开发阶段可以使用 `fallbackToDestructiveMigration()`

### 11.2 性能优化
- 使用索引优化查询性能
- 避免在主线程执行数据库操作
- 合理使用 Flow 和 LiveData

### 11.3 数据一致性
- 使用事务保证数据一致性
- 合理设置外键约束
- 注意并发访问问题