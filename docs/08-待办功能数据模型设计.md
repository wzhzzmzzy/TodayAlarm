# 定时提醒小助手 - 待办功能数据模型设计

## 1. 概述

本文档详细描述待办功能的数据模型设计，包括数据实体、数据库表结构、数据访问对象(DAO)、Repository模式实现，以及相关的工具类和扩展功能。

## 2. 数据实体设计

### 2.1 TodoItem 核心实体

```kotlin
// data/database/entities/TodoItem.kt
@Entity(
    tableName = "todo_items",
    foreignKeys = [
        ForeignKey(
            entity = Plan::class,
            parentColumns = ["id"],
            childColumns = ["planId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["planId"]),
        Index(value = ["isCompleted"]),
        Index(value = ["triggerTime"]),
        Index(value = ["priority"]),
        Index(value = ["category"])
    ]
)
data class TodoItem(
    @PrimaryKey
    val id: String = UUID.randomUUID().toString(),

    // 关联信息
    val planId: String,

    // 基础信息
    val title: String,
    val content: String,
    val description: String? = null,

    // 时间信息
    val triggerTime: Long,
    val dueTime: Long? = null,
    val completedAt: Long? = null,
    val createdAt: Long = System.currentTimeMillis(),
    val updatedAt: Long = System.currentTimeMillis(),

    // 状态信息
    val status: String = TodoStatus.PENDING.name,
    val isCompleted: Boolean = false,
    val isArchived: Boolean = false,

    // 分类和优先级
    val priority: String = TodoPriority.NORMAL.name,
    val category: String = TodoCategory.GENERAL.name,
    val tags: String = "", // JSON格式存储标签列表

    // 提醒设置
    val reminderEnabled: Boolean = true,
    val reminderTime: Long? = null,
    val snoozeCount: Int = 0,
    val maxSnoozeCount: Int = 3,

    // 扩展信息
    val metadata: String = "{}", // JSON格式存储扩展数据
    val attachments: String = "[]" // JSON格式存储附件信息
)
```

### 2.2 枚举类定义

```kotlin
// data/database/entities/TodoEnums.kt

enum class TodoStatus {
    PENDING,    // 待完成
    COMPLETED,  // 已完成
    OVERDUE,    // 已过期
    CANCELLED,  // 已取消
    SNOOZED     // 已推迟
}

enum class TodoPriority {
    LOW,        // 低优先级
    NORMAL,     // 普通优先级
    HIGH,       // 高优先级
    URGENT      // 紧急
}

enum class TodoCategory {
    GENERAL,    // 一般事项
    WORK,       // 工作相关
    PERSONAL,   // 个人事务
    HEALTH,     // 健康相关
    STUDY,      // 学习相关
    SHOPPING,   // 购物清单
    TRAVEL,     // 旅行计划
    CUSTOM      // 自定义分类
}
```

### 2.3 辅助数据类

```kotlin
// data/database/entities/TodoModels.kt

@Serializable
data class TodoTag(
    val id: String,
    val name: String,
    val color: String
)

@Serializable
data class TodoAttachment(
    val id: String,
    val name: String,
    val type: String, // image, audio, text
    val path: String,
    val size: Long,
    val createdAt: Long
)

@Serializable
data class TodoMetadata(
    val location: String? = null,
    val weather: String? = null,
    val mood: String? = null,
    val difficulty: Int? = null, // 1-5
    val estimatedDuration: Int? = null, // 分钟
    val actualDuration: Int? = null,
    val notes: String? = null
)

// 统计相关数据类
data class TodoStatistics(
    val totalCount: Int,
    val completedCount: Int,
    val pendingCount: Int,
    val overdueCount: Int,
    val completionRate: Float,
    val averageCompletionTime: Long,
    val categoryDistribution: Map<TodoCategory, Int>,
    val priorityDistribution: Map<TodoPriority, Int>
)

// 时间范围查询数据类
data class TodoTimeRange(
    val startTime: Long,
    val endTime: Long,
    val label: String
) {
    companion object {
        fun today(): TodoTimeRange {
            val now = Calendar.getInstance()
            val startOfDay = now.apply {
                set(Calendar.HOUR_OF_DAY, 0)
                set(Calendar.MINUTE, 0)
                set(Calendar.SECOND, 0)
                set(Calendar.MILLISECOND, 0)
            }.timeInMillis

            val endOfDay = now.apply {
                set(Calendar.HOUR_OF_DAY, 23)
                set(Calendar.MINUTE, 59)
                set(Calendar.SECOND, 59)
                set(Calendar.MILLISECOND, 999)
            }.timeInMillis

            return TodoTimeRange(startOfDay, endOfDay, "今天")
        }

        fun thisWeek(): TodoTimeRange {
            val now = Calendar.getInstance()
            val startOfWeek = now.apply {
                set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)
                set(Calendar.HOUR_OF_DAY, 0)
                set(Calendar.MINUTE, 0)
                set(Calendar.SECOND, 0)
                set(Calendar.MILLISECOND, 0)
            }.timeInMillis

            val endOfWeek = now.apply {
                add(Calendar.DAY_OF_WEEK, 6)
                set(Calendar.HOUR_OF_DAY, 23)
                set(Calendar.MINUTE, 59)
                set(Calendar.SECOND, 59)
                set(Calendar.MILLISECOND, 999)
            }.timeInMillis

            return TodoTimeRange(startOfWeek, endOfWeek, "本周")
        }
    }
}
```

## 3. 数据访问对象 (DAO)

### 3.1 TodoItemDao 核心接口

```kotlin
// data/database/dao/TodoItemDao.kt
@Dao
interface TodoItemDao {

    // ==================== 基础查询 ====================

    @Query("SELECT * FROM todo_items ORDER BY triggerTime DESC")
    fun getAllTodoItems(): Flow<List<TodoItem>>

    @Query("SELECT * FROM todo_items WHERE id = :id")
    suspend fun getTodoItemById(id: String): TodoItem?

    @Query("SELECT * FROM todo_items WHERE planId = :planId ORDER BY triggerTime DESC")
    fun getTodoItemsByPlanId(planId: String): Flow<List<TodoItem>>

    // ==================== 状态查询 ====================

    @Query("SELECT * FROM todo_items WHERE status = :status ORDER BY triggerTime ASC")
    fun getTodoItemsByStatus(status: String): Flow<List<TodoItem>>

    @Query("SELECT * FROM todo_items WHERE isCompleted = 0 AND isArchived = 0 ORDER BY triggerTime ASC")
    fun getPendingTodoItems(): Flow<List<TodoItem>>

    @Query("SELECT * FROM todo_items WHERE isCompleted = 1 ORDER BY completedAt DESC")
    fun getCompletedTodoItems(): Flow<List<TodoItem>>

    @Query("SELECT * FROM todo_items WHERE triggerTime < :currentTime AND isCompleted = 0 AND status != 'CANCELLED' ORDER BY triggerTime ASC")
    fun getOverdueTodoItems(currentTime: Long = System.currentTimeMillis()): Flow<List<TodoItem>>

    @Query("SELECT * FROM todo_items WHERE status = 'SNOOZED' ORDER BY reminderTime ASC")
    fun getSnoozedTodoItems(): Flow<List<TodoItem>>

    // ==================== 时间范围查询 ====================

    @Query("SELECT * FROM todo_items WHERE triggerTime BETWEEN :startTime AND :endTime ORDER BY triggerTime ASC")
    fun getTodoItemsInTimeRange(startTime: Long, endTime: Long): Flow<List<TodoItem>>

    @Query("SELECT * FROM todo_items WHERE DATE(triggerTime/1000, 'unixepoch', 'localtime') = DATE(:timestamp/1000, 'unixepoch', 'localtime') ORDER BY triggerTime ASC")
    fun getTodoItemsByDate(timestamp: Long): Flow<List<TodoItem>>

    @Query("SELECT * FROM todo_items WHERE completedAt BETWEEN :startTime AND :endTime ORDER BY completedAt DESC")
    fun getCompletedTodoItemsInTimeRange(startTime: Long, endTime: Long): Flow<List<TodoItem>>

    // ==================== 分类和优先级查询 ====================

    @Query("SELECT * FROM todo_items WHERE category = :category ORDER BY priority DESC, triggerTime ASC")
    fun getTodoItemsByCategory(category: String): Flow<List<TodoItem>>

    @Query("SELECT * FROM todo_items WHERE priority = :priority ORDER BY triggerTime ASC")
    fun getTodoItemsByPriority(priority: String): Flow<List<TodoItem>>

    @Query("SELECT * FROM todo_items WHERE category = :category AND priority = :priority ORDER BY triggerTime ASC")
    fun getTodoItemsByCategoryAndPriority(category: String, priority: String): Flow<List<TodoItem>>

    // ==================== 搜索查询 ====================

    @Query("SELECT * FROM todo_items WHERE title LIKE '%' || :query || '%' OR content LIKE '%' || :query || '%' ORDER BY triggerTime DESC")
    fun searchTodoItems(query: String): Flow<List<TodoItem>>

    @Query("SELECT * FROM todo_items WHERE tags LIKE '%' || :tag || '%' ORDER BY triggerTime DESC")
    fun getTodoItemsByTag(tag: String): Flow<List<TodoItem>>

    // ==================== 统计查询 ====================

    @Query("SELECT COUNT(*) FROM todo_items")
    suspend fun getTotalCount(): Int

    @Query("SELECT COUNT(*) FROM todo_items WHERE isCompleted = 1")
    suspend fun getCompletedCount(): Int

    @Query("SELECT COUNT(*) FROM todo_items WHERE isCompleted = 0 AND isArchived = 0")
    suspend fun getPendingCount(): Int

    @Query("SELECT COUNT(*) FROM todo_items WHERE triggerTime < :currentTime AND isCompleted = 0 AND status != 'CANCELLED'")
    suspend fun getOverdueCount(currentTime: Long = System.currentTimeMillis()): Int

    @Query("SELECT category, COUNT(*) as count FROM todo_items GROUP BY category")
    suspend fun getCategoryDistribution(): List<CategoryCount>

    @Query("SELECT priority, COUNT(*) as count FROM todo_items GROUP BY priority")
    suspend fun getPriorityDistribution(): List<PriorityCount>

    @Query("SELECT AVG(completedAt - triggerTime) FROM todo_items WHERE isCompleted = 1 AND completedAt > triggerTime")
    suspend fun getAverageCompletionTime(): Long?

    // ==================== 数据操作 ====================

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertTodoItem(todoItem: TodoItem)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertTodoItems(todoItems: List<TodoItem>)

    @Update
    suspend fun updateTodoItem(todoItem: TodoItem)

    @Update
    suspend fun updateTodoItems(todoItems: List<TodoItem>)

    @Delete
    suspend fun deleteTodoItem(todoItem: TodoItem)

    @Delete
    suspend fun deleteTodoItems(todoItems: List<TodoItem>)

    // ==================== 便捷更新方法 ====================

    @Query("UPDATE todo_items SET isCompleted = :isCompleted, completedAt = :completedAt, status = :status, updatedAt = :updatedAt WHERE id = :id")
    suspend fun updateTodoItemCompletionStatus(
        id: String,
        isCompleted: Boolean,
        completedAt: Long?,
        status: String,
        updatedAt: Long = System.currentTimeMillis()
    )

    @Query("UPDATE todo_items SET status = :status, updatedAt = :updatedAt WHERE id = :id")
    suspend fun updateTodoItemStatus(
        id: String,
        status: String,
        updatedAt: Long = System.currentTimeMillis()
    )

    @Query("UPDATE todo_items SET priority = :priority, updatedAt = :updatedAt WHERE id = :id")
    suspend fun updateTodoItemPriority(
        id: String,
        priority: String,
        updatedAt: Long = System.currentTimeMillis()
    )

    @Query("UPDATE todo_items SET category = :category, updatedAt = :updatedAt WHERE id = :id")
    suspend fun updateTodoItemCategory(
        id: String,
        category: String,
        updatedAt: Long = System.currentTimeMillis()
    )

    @Query("UPDATE todo_items SET reminderTime = :reminderTime, snoozeCount = snoozeCount + 1, status = 'SNOOZED', updatedAt = :updatedAt WHERE id = :id")
    suspend fun snoozeTodoItem(
        id: String,
        reminderTime: Long,
        updatedAt: Long = System.currentTimeMillis()
    )

    @Query("UPDATE todo_items SET isArchived = :isArchived, updatedAt = :updatedAt WHERE id = :id")
    suspend fun archiveTodoItem(
        id: String,
        isArchived: Boolean,
        updatedAt: Long = System.currentTimeMillis()
    )

    // ==================== 批量操作 ====================

    @Query("UPDATE todo_items SET isCompleted = 1, completedAt = :completedAt, status = 'COMPLETED', updatedAt = :updatedAt WHERE id IN (:ids)")
    suspend fun batchCompleteTodoItems(
        ids: List<String>,
        completedAt: Long = System.currentTimeMillis(),
        updatedAt: Long = System.currentTimeMillis()
    )

    @Query("UPDATE todo_items SET isArchived = 1, updatedAt = :updatedAt WHERE id IN (:ids)")
    suspend fun batchArchiveTodoItems(
        ids: List<String>,
        updatedAt: Long = System.currentTimeMillis()
    )

    @Query("DELETE FROM todo_items WHERE id IN (:ids)")
    suspend fun batchDeleteTodoItems(ids: List<String>)

    @Query("DELETE FROM todo_items WHERE planId = :planId")
    suspend fun deleteTodoItemsByPlanId(planId: String)

    @Query("DELETE FROM todo_items WHERE isCompleted = 1 AND completedAt < :beforeTime")
    suspend fun deleteOldCompletedTodoItems(beforeTime: Long)

    // ==================== 清理操作 ====================

    @Query("DELETE FROM todo_items WHERE isArchived = 1")
    suspend fun deleteArchivedTodoItems()

    @Query("DELETE FROM todo_items WHERE status = 'CANCELLED'")
    suspend fun deleteCancelledTodoItems()

    @Query("UPDATE todo_items SET status = 'OVERDUE' WHERE triggerTime < :currentTime AND isCompleted = 0 AND status = 'PENDING'")
    suspend fun updateOverdueTodoItems(currentTime: Long = System.currentTimeMillis())
}

// 统计查询的数据类
data class CategoryCount(
    val category: String,
    val count: Int
)

data class PriorityCount(
    val priority: String,
    val count: Int
)
```

## 4. Repository 接口和实现

### 4.1 Repository 接口

```kotlin
// domain/repository/TodoItemRepository.kt
interface TodoItemRepository {

    // ==================== 基础操作 ====================
    fun getAllTodoItems(): Flow<List<TodoItem>>
    suspend fun getTodoItemById(id: String): TodoItem?
    fun getTodoItemsByPlanId(planId: String): Flow<List<TodoItem>>
    suspend fun insertTodoItem(todoItem: TodoItem)
    suspend fun updateTodoItem(todoItem: TodoItem)
    suspend fun deleteTodoItem(todoItem: TodoItem)

    // ==================== 状态管理 ====================
    fun getTodoItemsByStatus(status: TodoStatus): Flow<List<TodoItem>>
    fun getPendingTodoItems(): Flow<List<TodoItem>>
    fun getCompletedTodoItems(): Flow<List<TodoItem>>
    fun getOverdueTodoItems(): Flow<List<TodoItem>>
    fun getSnoozedTodoItems(): Flow<List<TodoItem>>

    // ==================== 时间查询 ====================
    fun getTodoItemsInTimeRange(startTime: Long, endTime: Long): Flow<List<TodoItem>>
    fun getTodoItemsByDate(timestamp: Long): Flow<List<TodoItem>>
    fun getTodayTodoItems(): Flow<List<TodoItem>>
    fun getThisWeekTodoItems(): Flow<List<TodoItem>>

    // ==================== 分类查询 ====================
    fun getTodoItemsByCategory(category: TodoCategory): Flow<List<TodoItem>>
    fun getTodoItemsByPriority(priority: TodoPriority): Flow<List<TodoItem>>
    fun searchTodoItems(query: String): Flow<List<TodoItem>>

    // ==================== 状态更新 ====================
    suspend fun completeTodoItem(id: String)
    suspend fun uncompleteTodoItem(id: String)
    suspend fun cancelTodoItem(id: String)
    suspend fun snoozeTodoItem(id: String, snoozeMinutes: Int)
    suspend fun updateTodoItemPriority(id: String, priority: TodoPriority)
    suspend fun updateTodoItemCategory(id: String, category: TodoCategory)
    suspend fun archiveTodoItem(id: String)

    // ==================== 批量操作 ====================
    suspend fun batchCompleteTodoItems(ids: List<String>)
    suspend fun batchDeleteTodoItems(ids: List<String>)
    suspend fun batchArchiveTodoItems(ids: List<String>)

    // ==================== 统计功能 ====================
    suspend fun getTodoStatistics(): TodoStatistics
    suspend fun getTodoStatisticsInTimeRange(startTime: Long, endTime: Long): TodoStatistics

    // ==================== 清理功能 ====================
    suspend fun cleanupOldCompletedTodos(daysOld: Int = 30)
    suspend fun updateOverdueTodos()
}
```

### 4.2 Repository 实现

```kotlin
// data/repository/TodoItemRepositoryImpl.kt
@Singleton
class TodoItemRepositoryImpl @Inject constructor(
    private val todoItemDao: TodoItemDao,
    private val dispatcher: CoroutineDispatcher = Dispatchers.IO
) : TodoItemRepository {

    // ==================== 基础操作 ====================

    override fun getAllTodoItems(): Flow<List<TodoItem>> = todoItemDao.getAllTodoItems()

    override suspend fun getTodoItemById(id: String): TodoItem? =
        withContext(dispatcher) {
            todoItemDao.getTodoItemById(id)
        }

    override fun getTodoItemsByPlanId(planId: String): Flow<List<TodoItem>> =
        todoItemDao.getTodoItemsByPlanId(planId)

    override suspend fun insertTodoItem(todoItem: TodoItem) =
        withContext(dispatcher) {
            todoItemDao.insertTodoItem(todoItem)
        }

    override suspend fun updateTodoItem(todoItem: TodoItem) =
        withContext(dispatcher) {
            todoItemDao.updateTodoItem(todoItem.copy(updatedAt = System.currentTimeMillis()))
        }

    override suspend fun deleteTodoItem(todoItem: TodoItem) =
        withContext(dispatcher) {
            todoItemDao.deleteTodoItem(todoItem)
        }

    // ==================== 状态管理 ====================

    override fun getTodoItemsByStatus(status: TodoStatus): Flow<List<TodoItem>> =
        todoItemDao.getTodoItemsByStatus(status.name)

    override fun getPendingTodoItems(): Flow<List<TodoItem>> =
        todoItemDao.getPendingTodoItems()

    override fun getCompletedTodoItems(): Flow<List<TodoItem>> =
        todoItemDao.getCompletedTodoItems()

    override fun getOverdueTodoItems(): Flow<List<TodoItem>> =
        todoItemDao.getOverdueTodoItems()

    override fun getSnoozedTodoItems(): Flow<List<TodoItem>> =
        todoItemDao.getSnoozedTodoItems()

    // ==================== 时间查询 ====================

    override fun getTodoItemsInTimeRange(startTime: Long, endTime: Long): Flow<List<TodoItem>> =
        todoItemDao.getTodoItemsInTimeRange(startTime, endTime)

    override fun getTodoItemsByDate(timestamp: Long): Flow<List<TodoItem>> =
        todoItemDao.getTodoItemsByDate(timestamp)

    override fun getTodayTodoItems(): Flow<List<TodoItem>> =
        TodoTimeRange.today().let { range ->
            todoItemDao.getTodoItemsInTimeRange(range.startTime, range.endTime)
        }

    override fun getThisWeekTodoItems(): Flow<List<TodoItem>> =
        TodoTimeRange.thisWeek().let { range ->
            todoItemDao.getTodoItemsInTimeRange(range.startTime, range.endTime)
        }

    // ==================== 分类查询 ====================

    override fun getTodoItemsByCategory(category: TodoCategory): Flow<List<TodoItem>> =
        todoItemDao.getTodoItemsByCategory(category.name)

    override fun getTodoItemsByPriority(priority: TodoPriority): Flow<List<TodoItem>> =
        todoItemDao.getTodoItemsByPriority(priority.name)

    override fun searchTodoItems(query: String): Flow<List<TodoItem>> =
        todoItemDao.searchTodoItems(query)

    // ==================== 状态更新 ====================

    override suspend fun completeTodoItem(id: String) =
        withContext(dispatcher) {
            val now = System.currentTimeMillis()
            todoItemDao.updateTodoItemCompletionStatus(
                id = id,
                isCompleted = true,
                completedAt = now,
                status = TodoStatus.COMPLETED.name,
                updatedAt = now
            )
        }

    override suspend fun uncompleteTodoItem(id: String) =
        withContext(dispatcher) {
            todoItemDao.updateTodoItemCompletionStatus(
                id = id,
                isCompleted = false,
                completedAt = null,
                status = TodoStatus.PENDING.name
            )
        }

    override suspend fun cancelTodoItem(id: String) =
        withContext(dispatcher) {
            todoItemDao.updateTodoItemStatus(id, TodoStatus.CANCELLED.name)
        }

    override suspend fun snoozeTodoItem(id: String, snoozeMinutes: Int) =
        withContext(dispatcher) {
            val snoozeTime = System.currentTimeMillis() + (snoozeMinutes * 60 * 1000)
            todoItemDao.snoozeTodoItem(id, snoozeTime)
        }

    override suspend fun updateTodoItemPriority(id: String, priority: TodoPriority) =
        withContext(dispatcher) {
            todoItemDao.updateTodoItemPriority(id, priority.name)
        }

    override suspend fun updateTodoItemCategory(id: String, category: TodoCategory) =
        withContext(dispatcher) {
            todoItemDao.updateTodoItemCategory(id, category.name)
        }

    override suspend fun archiveTodoItem(id: String) =
        withContext(dispatcher) {
            todoItemDao.archiveTodoItem(id, true)
        }

    // ==================== 批量操作 ====================

    override suspend fun batchCompleteTodoItems(ids: List<String>) =
        withContext(dispatcher) {
            todoItemDao.batchCompleteTodoItems(ids)
        }

    override suspend fun batchDeleteTodoItems(ids: List<String>) =
        withContext(dispatcher) {
            todoItemDao.batchDeleteTodoItems(ids)
        }

    override suspend fun batchArchiveTodoItems(ids: List<String>) =
        withContext(dispatcher) {
            todoItemDao.batchArchiveTodoItems(ids)
        }

    // ==================== 统计功能 ====================

    override suspend fun getTodoStatistics(): TodoStatistics =
        withContext(dispatcher) {
            val totalCount = todoItemDao.getTotalCount()
            val completedCount = todoItemDao.getCompletedCount()
            val pendingCount = todoItemDao.getPendingCount()
            val overdueCount = todoItemDao.getOverdueCount()
            val categoryDistribution = todoItemDao.getCategoryDistribution()
                .associate { TodoCategory.valueOf(it.category) to it.count }
            val priorityDistribution = todoItemDao.getPriorityDistribution()
                .associate { TodoPriority.valueOf(it.priority) to it.count }
            val averageCompletionTime = todoItemDao.getAverageCompletionTime() ?: 0L

            TodoStatistics(
                totalCount = totalCount,
                completedCount = completedCount,
                pendingCount = pendingCount,
                overdueCount = overdueCount,
                completionRate = if (totalCount > 0) completedCount.toFloat() / totalCount else 0f,
                averageCompletionTime = averageCompletionTime,
                categoryDistribution = categoryDistribution,
                priorityDistribution = priorityDistribution
            )
        }

    override suspend fun getTodoStatisticsInTimeRange(startTime: Long, endTime: Long): TodoStatistics =
        withContext(dispatcher) {
            // 实现时间范围内的统计查询
            // 这里需要添加相应的DAO方法
            getTodoStatistics() // 简化实现，实际应该基于时间范围查询
        }

    // ==================== 清理功能 ====================

    override suspend fun cleanupOldCompletedTodos(daysOld: Int) =
        withContext(dispatcher) {
            val cutoffTime = System.currentTimeMillis() - (daysOld * 24 * 60 * 60 * 1000L)
            todoItemDao.deleteOldCompletedTodoItems(cutoffTime)
        }

    override suspend fun updateOverdueTodos() =
        withContext(dispatcher) {
            todoItemDao.updateOverdueTodoItems()
        }
}
```

## 5. 类型转换器

```kotlin
// data/database/converters/TodoConverters.kt
class TodoConverters {

    private val json = Json { ignoreUnknownKeys = true }

    // ==================== 枚举转换 ====================

    @TypeConverter
    fun fromTodoStatus(status: TodoStatus): String = status.name

    @TypeConverter
    fun toTodoStatus(status: String): TodoStatus =
        try {
            TodoStatus.valueOf(status)
        } catch (e: IllegalArgumentException) {
            TodoStatus.PENDING
        }

    @TypeConverter
    fun fromTodoPriority(priority: TodoPriority): String = priority.name

    @TypeConverter
    fun toTodoPriority(priority: String): TodoPriority =
        try {
            TodoPriority.valueOf(priority)
        } catch (e: IllegalArgumentException) {
            TodoPriority.NORMAL
        }

    @TypeConverter
    fun fromTodoCategory(category: TodoCategory): String = category.name

    @TypeConverter
    fun toTodoCategory(category: String): TodoCategory =
        try {
            TodoCategory.valueOf(category)
        } catch (e: IllegalArgumentException) {
            TodoCategory.GENERAL
        }

    // ==================== JSON转换 ====================

    @TypeConverter
    fun fromTodoTagList(tags: List<TodoTag>): String =
        json.encodeToString(tags)

    @TypeConverter
    fun toTodoTagList(tagsJson: String): List<TodoTag> =
        try {
            json.decodeFromString(tagsJson)
        } catch (e: Exception) {
            emptyList()
        }

    @TypeConverter
    fun fromTodoAttachmentList(attachments: List<TodoAttachment>): String =
        json.encodeToString(attachments)

    @TypeConverter
    fun toTodoAttachmentList(attachmentsJson: String): List<TodoAttachment> =
        try {
            json.decodeFromString(attachmentsJson)
        } catch (e: Exception) {
            emptyList()
        }

    @TypeConverter
    fun fromTodoMetadata(metadata: TodoMetadata): String =
        json.encodeToString(metadata)

    @TypeConverter
    fun toTodoMetadata(metadataJson: String): TodoMetadata =
        try {
            json.decodeFromString(metadataJson)
        } catch (e: Exception) {
            TodoMetadata()
        }
}
```

## 6. 数据库配置更新

```kotlin
// data/database/AppDatabase.kt (更新版本)
@Database(
    entities = [Plan::class, TodoItem::class],
    version = 2, // 版本升级
    exportSchema = true
)
@TypeConverters(Converters::class, TodoConverters::class)
abstract class AppDatabase : RoomDatabase() {

    abstract fun planDao(): PlanDao
    abstract fun todoItemDao(): TodoItemDao

    companion object {
        const val DATABASE_NAME = "today_alarm_database"
    }
}
```

## 7. 工具类和扩展函数

### 7.1 TodoItem 扩展函数

```kotlin
// data/database/entities/TodoItemExtensions.kt

// 状态检查扩展
fun TodoItem.isPending(): Boolean = status == TodoStatus.PENDING.name && !isCompleted
fun TodoItem.isCompleted(): Boolean = isCompleted && status == TodoStatus.COMPLETED.name
fun TodoItem.isOverdue(): Boolean = status == TodoStatus.OVERDUE.name ||
    (triggerTime < System.currentTimeMillis() && !isCompleted && status != TodoStatus.CANCELLED.name)
fun TodoItem.isSnoozed(): Boolean = status == TodoStatus.SNOOZED.name
fun TodoItem.isCancelled(): Boolean = status == TodoStatus.CANCELLED.name

// 时间相关扩展
fun TodoItem.isToday(): Boolean {
    val today = TodoTimeRange.today()
    return triggerTime in today.startTime..today.endTime
}

fun TodoItem.isThisWeek(): Boolean {
    val thisWeek = TodoTimeRange.thisWeek()
    return triggerTime in thisWeek.startTime..thisWeek.endTime
}

fun TodoItem.getDaysUntilDue(): Int {
    val now = System.currentTimeMillis()
    val diffInMillis = triggerTime - now
    return (diffInMillis / (24 * 60 * 60 * 1000)).toInt()
}

// 优先级相关扩展
fun TodoItem.getPriorityEnum(): TodoPriority =
    try {
        TodoPriority.valueOf(priority)
    } catch (e: IllegalArgumentException) {
        TodoPriority.NORMAL
    }

fun TodoItem.getCategoryEnum(): TodoCategory =
    try {
        TodoCategory.valueOf(category)
    } catch (e: IllegalArgumentException) {
        TodoCategory.GENERAL
    }

// 标签相关扩展
fun TodoItem.getTagList(): List<TodoTag> =
    try {
        Json.decodeFromString(tags)
    } catch (e: Exception) {
        emptyList()
    }

fun TodoItem.hasTag(tagName: String): Boolean =
    getTagList().any { it.name.equals(tagName, ignoreCase = true) }

// 附件相关扩展
fun TodoItem.getAttachmentList(): List<TodoAttachment> =
    try {
        Json.decodeFromString(attachments)
    } catch (e: Exception) {
        emptyList()
    }

fun TodoItem.hasAttachments(): Boolean = getAttachmentList().isNotEmpty()

// 元数据相关扩展
fun TodoItem.getMetadataObject(): TodoMetadata =
    try {
        Json.decodeFromString(metadata)
    } catch (e: Exception) {
        TodoMetadata()
    }

// 推迟相关扩展
fun TodoItem.canSnooze(): Boolean = snoozeCount < maxSnoozeCount && !isCompleted()

fun TodoItem.getNextSnoozeTime(minutes: Int): Long =
    System.currentTimeMillis() + (minutes * 60 * 1000)
```

### 7.2 TodoItem 工厂类

```kotlin
// data/database/entities/TodoItemFactory.kt
object TodoItemFactory {

    fun createFromPlan(plan: Plan, triggerTime: Long = plan.triggerTime): TodoItem {
        return TodoItem(
            planId = plan.id,
            title = plan.title,
            content = plan.content,
            triggerTime = triggerTime,
            priority = inferPriorityFromContent(plan.content),
            category = inferCategoryFromContent(plan.content),
            reminderEnabled = true,
            reminderTime = triggerTime
        )
    }

    fun createQuickTodo(
        title: String,
        content: String = "",
        triggerTime: Long = System.currentTimeMillis(),
        priority: TodoPriority = TodoPriority.NORMAL,
        category: TodoCategory = TodoCategory.GENERAL
    ): TodoItem {
        return TodoItem(
            planId = "", // 快速创建的待办不关联计划
            title = title,
            content = content,
            triggerTime = triggerTime,
            priority = priority.name,
            category = category.name
        )
    }

    private fun inferPriorityFromContent(content: String): String {
        val urgentKeywords = listOf("紧急", "urgent", "asap", "立即", "马上")
        val highKeywords = listOf("重要", "important", "关键", "key")

        return when {
            urgentKeywords.any { content.contains(it, ignoreCase = true) } -> TodoPriority.URGENT.name
            highKeywords.any { content.contains(it, ignoreCase = true) } -> TodoPriority.HIGH.name
            else -> TodoPriority.NORMAL.name
        }
    }

    private fun inferCategoryFromContent(content: String): String {
        val workKeywords = listOf("工作", "会议", "项目", "work", "meeting", "project")
        val healthKeywords = listOf("运动", "健身", "医院", "体检", "health", "exercise")
        val studyKeywords = listOf("学习", "考试", "作业", "study", "exam", "homework")
        val shoppingKeywords = listOf("购物", "买", "shopping", "buy")

        return when {
            workKeywords.any { content.contains(it, ignoreCase = true) } -> TodoCategory.WORK.name
            healthKeywords.any { content.contains(it, ignoreCase = true) } -> TodoCategory.HEALTH.name
            studyKeywords.any { content.contains(it, ignoreCase = true) } -> TodoCategory.STUDY.name
            shoppingKeywords.any { content.contains(it, ignoreCase = true) } -> TodoCategory.SHOPPING.name
            else -> TodoCategory.GENERAL.name
        }
    }
}
```

## 8. 测试数据和Mock

```kotlin
// data/database/entities/TodoTestData.kt
object TodoTestData {

    fun createSampleTodoItems(): List<TodoItem> {
        val now = System.currentTimeMillis()
        val oneHour = 60 * 60 * 1000L
        val oneDay = 24 * oneHour

        return listOf(
            // 今天的待办
            TodoItem(
                planId = "plan1",
                title = "晨练",
                content = "去公园跑步30分钟",
                triggerTime = now + oneHour,
                priority = TodoPriority.HIGH.name,
                category = TodoCategory.HEALTH.name,
                tags = Json.encodeToString(listOf(TodoTag("1", "运动", "#FF5722"))),
                metadata = Json.encodeToString(TodoMetadata(estimatedDuration = 30))
            ),

            // 已完成的待办
            TodoItem(
                planId = "plan2",
                title = "项目会议",
                content = "讨论新功能开发计划",
                triggerTime = now - oneHour,
                isCompleted = true,
                completedAt = now - 30 * 60 * 1000,
                priority = TodoPriority.URGENT.name,
                category = TodoCategory.WORK.name,
                status = TodoStatus.COMPLETED.name
            ),

            // 过期的待办
            TodoItem(
                planId = "plan3",
                title = "买菜",
                content = "购买周末聚餐的食材",
                triggerTime = now - oneDay,
                priority = TodoPriority.NORMAL.name,
                category = TodoCategory.SHOPPING.name,
                status = TodoStatus.OVERDUE.name
            ),

            // 推迟的待办
            TodoItem(
                planId = "plan4",
                title = "学习新技术",
                content = "阅读Kotlin协程相关文档",
                triggerTime = now + 2 * oneHour,
                priority = TodoPriority.LOW.name,
                category = TodoCategory.STUDY.name,
                status = TodoStatus.SNOOZED.name,
                snoozeCount = 1,
                reminderTime = now + 3 * oneHour
            )
        )
    }

    fun createMockStatistics(): TodoStatistics {
        return TodoStatistics(
            totalCount = 50,
            completedCount = 35,
            pendingCount = 10,
            overdueCount = 5,
            completionRate = 0.7f,
            averageCompletionTime = 2 * 60 * 60 * 1000L, // 2小时
            categoryDistribution = mapOf(
                TodoCategory.WORK to 20,
                TodoCategory.PERSONAL to 15,
                TodoCategory.HEALTH to 8,
                TodoCategory.STUDY to 5,
                TodoCategory.SHOPPING to 2
            ),
            priorityDistribution = mapOf(
                TodoPriority.LOW to 15,
                TodoPriority.NORMAL to 25,
                TodoPriority.HIGH to 8,
                TodoPriority.URGENT to 2
            )
        )
    }
}
```

## 9. 数据迁移策略

```kotlin
// data/database/migration/TodoMigrations.kt
object TodoMigrations {

    val MIGRATION_1_2 = object : Migration(1, 2) {
        override fun migrate(database: SupportSQLiteDatabase) {
            // 添加新的待办表
            database.execSQL("""
                CREATE TABLE IF NOT EXISTS `todo_items` (
                    `id` TEXT NOT NULL,
                    `planId` TEXT NOT NULL,
                    `title` TEXT NOT NULL,
                    `content` TEXT NOT NULL,
                    `description` TEXT,
                    `triggerTime` INTEGER NOT NULL,
                    `dueTime` INTEGER,
                    `completedAt` INTEGER,
                    `createdAt` INTEGER NOT NULL,
                    `updatedAt` INTEGER NOT NULL,
                    `status` TEXT NOT NULL,
                    `isCompleted` INTEGER NOT NULL,
                    `isArchived` INTEGER NOT NULL,
                    `priority` TEXT NOT NULL,
                    `category` TEXT NOT NULL,
                    `tags` TEXT NOT NULL,
                    `reminderEnabled` INTEGER NOT NULL,
                    `reminderTime` INTEGER,
                    `snoozeCount` INTEGER NOT NULL,
                    `maxSnoozeCount` INTEGER NOT NULL,
                    `metadata` TEXT NOT NULL,
                    `attachments` TEXT NOT NULL,
                    PRIMARY KEY(`id`),
                    FOREIGN KEY(`planId`) REFERENCES `plans`(`id`) ON DELETE CASCADE
                )
            """.trimIndent())

            // 创建索引
            database.execSQL("CREATE INDEX IF NOT EXISTS `index_todo_items_planId` ON `todo_items` (`planId`)")
            database.execSQL("CREATE INDEX IF NOT EXISTS `index_todo_items_isCompleted` ON `todo_items` (`isCompleted`)")
            database.execSQL("CREATE INDEX IF NOT EXISTS `index_todo_items_triggerTime` ON `todo_items` (`triggerTime`)")
            database.execSQL("CREATE INDEX IF NOT EXISTS `index_todo_items_priority` ON `todo_items` (`priority`)")
            database.execSQL("CREATE INDEX IF NOT EXISTS `index_todo_items_category` ON `todo_items` (`category`)")
        }
    }
}
```

## 10. 下一步

数据模型设计完成后，接下来需要：

1. **业务逻辑设计** (09-待办功能业务逻辑设计.md)
   - UseCase 设计和实现
   - ViewModel 架构
   - 数据流管理

2. **UI设计实现** (10-待办功能UI设计实现.md)
   - Compose UI 组件
   - 页面布局设计
   - 交互逻辑实现

3. **系统集成** (11-待办功能系统集成.md)
   - 通知系统集成
   - 闹钟触发处理
   - 后台任务管理

这个数据模型设计为待办功能提供了完整的数据基础，支持复杂的查询、统计和管理操作。